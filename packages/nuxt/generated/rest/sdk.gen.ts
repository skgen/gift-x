// This file is auto-generated by @hey-api/openapi-ts

import { type Client, formDataBodySerializer, type Options as Options2, type TDataShape } from './client';
import { client } from './client.gen';
import type { AcceptInviteData, AcceptInviteErrors, AcceptInviteResponses, ClearCacheData, ClearCacheResponses, CompareContentVersionData, CompareContentVersionErrors, CompareContentVersionResponses, CreateCollectionData, CreateCollectionErrors, CreateCollectionResponses, CreateCommentData, CreateCommentErrors, CreateCommentResponses, CreateContentVersionData, CreateContentVersionErrors, CreateContentVersionResponses, CreateFieldData, CreateFieldErrors, CreateFieldResponses, CreateFileData, CreateFileErrors, CreateFileResponses, CreateFlowData, CreateFlowErrors, CreateFlowResponses, CreateFolderData, CreateFolderErrors, CreateFolderResponses, CreateItemsEventData, CreateItemsEventErrors, CreateItemsEventResponses, CreateItemsWishData, CreateItemsWishErrors, CreateItemsWishListData, CreateItemsWishListErrors, CreateItemsWishListResponses, CreateItemsWishResponses, CreateOperationData, CreateOperationErrors, CreateOperationResponses, CreatePermissionData, CreatePermissionErrors, CreatePermissionResponses, CreatePresetData, CreatePresetErrors, CreatePresetResponses, CreateRelationData, CreateRelationErrors, CreateRelationResponses, CreateRoleData, CreateRoleErrors, CreateRoleResponses, CreateUserData, CreateUserErrors, CreateUserResponses, CreateWebhookData, CreateWebhookErrors, CreateWebhookResponses, DeleteCollectionData, DeleteCollectionErrors, DeleteCollectionResponses, DeleteCommentData, DeleteCommentErrors, DeleteCommentResponses, DeleteCommentsData, DeleteCommentsErrors, DeleteCommentsResponses, DeleteContentVersionData, DeleteContentVersionErrors, DeleteContentVersionResponses, DeleteContentVersionsData, DeleteContentVersionsErrors, DeleteContentVersionsResponses, DeleteFieldData, DeleteFieldErrors, DeleteFieldResponses, DeleteFileData, DeleteFileErrors, DeleteFileResponses, DeleteFilesData, DeleteFilesErrors, DeleteFilesResponses, DeleteFlowData, DeleteFlowErrors, DeleteFlowResponses, DeleteFlowsData, DeleteFlowsErrors, DeleteFlowsResponses, DeleteFolderData, DeleteFolderErrors, DeleteFolderResponses, DeleteFoldersData, DeleteFoldersErrors, DeleteFoldersResponses, DeleteItemsEventData, DeleteItemsEventErrors, DeleteItemsEventResponses, DeleteItemsWishData, DeleteItemsWishErrors, DeleteItemsWishListData, DeleteItemsWishListErrors, DeleteItemsWishListResponses, DeleteItemsWishResponses, DeleteOperationData, DeleteOperationErrors, DeleteOperationResponses, DeleteOperationsData, DeleteOperationsErrors, DeleteOperationsResponses, DeletePermissionData, DeletePermissionErrors, DeletePermissionResponses, DeletePermissionsData, DeletePermissionsErrors, DeletePermissionsResponses, DeletePresetData, DeletePresetErrors, DeletePresetResponses, DeletePresetsData, DeletePresetsErrors, DeletePresetsResponses, DeleteRelationData, DeleteRelationErrors, DeleteRelationResponses, DeleteRoleData, DeleteRoleErrors, DeleteRoleResponses, DeleteRolesData, DeleteRolesErrors, DeleteRolesResponses, DeleteSingleItemsEventData, DeleteSingleItemsEventErrors, DeleteSingleItemsEventResponses, DeleteSingleItemsWishData, DeleteSingleItemsWishErrors, DeleteSingleItemsWishListData, DeleteSingleItemsWishListErrors, DeleteSingleItemsWishListResponses, DeleteSingleItemsWishResponses, DeleteUserData, DeleteUserErrors, DeleteUserResponses, DeleteUsersData, DeleteUsersErrors, DeleteUsersResponses, DeleteWebhookData, DeleteWebhookErrors, DeleteWebhookResponses, DeleteWebhooksData, DeleteWebhooksErrors, DeleteWebhooksResponses, ExportData, ExportResponses, GetActivitiesData, GetActivitiesErrors, GetActivitiesResponses, GetActivityData, GetActivityErrors, GetActivityResponses, GetAssetData, GetAssetErrors, GetAssetResponses, GetCollectionData, GetCollectionErrors, GetCollectionFieldData, GetCollectionFieldErrors, GetCollectionFieldResponses, GetCollectionFieldsData, GetCollectionFieldsErrors, GetCollectionFieldsResponses, GetCollectionResponses, GetCollectionsData, GetCollectionsErrors, GetCollectionsResponses, GetCommentData, GetCommentErrors, GetCommentResponses, GetCommentsData, GetCommentsErrors, GetCommentsResponses, GetContentVersionData, GetContentVersionErrors, GetContentVersionResponses, GetContentVersionsData, GetContentVersionsErrors, GetContentVersionsResponses, GetFieldsData, GetFieldsErrors, GetFieldsResponses, GetFileData, GetFileErrors, GetFileResponses, GetFilesData, GetFilesErrors, GetFilesResponses, GetFlowData, GetFlowErrors, GetFlowResponses, GetFlowsData, GetFlowsErrors, GetFlowsResponses, GetFolderData, GetFolderErrors, GetFolderResponses, GetFoldersData, GetFoldersErrors, GetFoldersResponses, GetMeData, GetMeErrors, GetMeResponses, GetMyPermissionsData, GetMyPermissionsErrors, GetMyPermissionsResponses, GetOperationData, GetOperationErrors, GetOperationResponses, GetOperationsData, GetOperationsErrors, GetOperationsResponses, GetPermissionData, GetPermissionErrors, GetPermissionResponses, GetPermissionsData, GetPermissionsErrors, GetPermissionsResponses, GetPresetData, GetPresetErrors, GetPresetResponses, GetPresetsData, GetPresetsErrors, GetPresetsResponses, GetRelationData, GetRelationErrors, GetRelationResponses, GetRelationsData, GetRelationsErrors, GetRelationsResponses, GetRevisionData, GetRevisionErrors, GetRevisionResponses, GetRevisionsData, GetRevisionsErrors, GetRevisionsResponses, GetRoleData, GetRoleErrors, GetRoleResponses, GetRolesData, GetRolesErrors, GetRolesResponses, GetSettingsData, GetSettingsErrors, GetSettingsResponses, GetUserData, GetUserErrors, GetUserResponses, GetUsersData, GetUsersErrors, GetUsersResponses, GetWebhookData, GetWebhookErrors, GetWebhookResponses, GetWebhooksData, GetWebhooksErrors, GetWebhooksResponses, HashGenerateData, HashGenerateResponses, HashVerifyData, HashVerifyResponses, ImportData, ImportResponses, InviteData, InviteErrors, InviteResponses, ListExtensionsData, ListExtensionsErrors, ListExtensionsResponses, LoginData, LoginResponses, LogoutData, LogoutResponses, MeTfaDisableData, MeTfaDisableErrors, MeTfaDisableResponses, MeTfaEnableData, MeTfaEnableErrors, MeTfaEnableResponses, OauthData, OauthErrors, OauthProviderData, OauthProviderErrors, OauthProviderResponses, OauthResponses, PasswordRequestData, PasswordRequestErrors, PasswordResetData, PasswordResetErrors, PingData, PingResponses, PromoteContentVersionData, PromoteContentVersionErrors, PromoteContentVersionResponses, RandomData, RandomResponses, ReadItemsEventData, ReadItemsEventErrors, ReadItemsEventResponses, ReadItemsWishData, ReadItemsWishErrors, ReadItemsWishListData, ReadItemsWishListErrors, ReadItemsWishListResponses, ReadItemsWishResponses, ReadSingleItemsEventData, ReadSingleItemsEventErrors, ReadSingleItemsEventResponses, ReadSingleItemsWishData, ReadSingleItemsWishErrors, ReadSingleItemsWishListData, ReadSingleItemsWishListErrors, ReadSingleItemsWishListResponses, ReadSingleItemsWishResponses, RefreshData, RefreshErrors, RefreshResponses, SaveContentVersionData, SaveContentVersionErrors, SaveContentVersionResponses, SchemaApplyData, SchemaApplyErrors, SchemaApplyResponses, SchemaDiffData, SchemaDiffErrors, SchemaDiffResponses, SchemaSnapshotData, SchemaSnapshotErrors, SchemaSnapshotResponses, ServerInfoData, ServerInfoErrors, ServerInfoResponses, SortData, SortResponses, UpdateCollectionData, UpdateCollectionErrors, UpdateCollectionResponses, UpdateCommentData, UpdateCommentErrors, UpdateCommentResponses, UpdateCommentsData, UpdateCommentsErrors, UpdateCommentsResponses, UpdateContentVersionData, UpdateContentVersionErrors, UpdateContentVersionResponses, UpdateContentVersionsData, UpdateContentVersionsErrors, UpdateContentVersionsResponses, UpdateExtensionBundleData, UpdateExtensionBundleErrors, UpdateExtensionBundleResponses, UpdateExtensionsData, UpdateExtensionsErrors, UpdateExtensionsResponses, UpdateFieldData, UpdateFieldErrors, UpdateFieldResponses, UpdateFileData, UpdateFileErrors, UpdateFileResponses, UpdateFilesData, UpdateFilesErrors, UpdateFilesResponses, UpdateFlowData, UpdateFlowErrors, UpdateFlowResponses, UpdateFlowsData, UpdateFlowsErrors, UpdateFlowsResponses, UpdateFolderData, UpdateFolderErrors, UpdateFolderResponses, UpdateFoldersData, UpdateFoldersErrors, UpdateFoldersResponses, UpdateItemsEventData, UpdateItemsEventResponses, UpdateItemsWishData, UpdateItemsWishListData, UpdateItemsWishListResponses, UpdateItemsWishResponses, UpdateLastUsedPageMeData, UpdateLastUsedPageMeErrors, UpdateLastUsedPageMeResponses, UpdateMeData, UpdateMeErrors, UpdateMeResponses, UpdateOperationData, UpdateOperationErrors, UpdateOperationResponses, UpdateOperationsData, UpdateOperationsErrors, UpdateOperationsResponses, UpdatePermissionData, UpdatePermissionErrors, UpdatePermissionResponses, UpdatePermissionsData, UpdatePermissionsErrors, UpdatePermissionsResponses, UpdatePresetData, UpdatePresetErrors, UpdatePresetResponses, UpdatePresetsData, UpdatePresetsErrors, UpdatePresetsResponses, UpdateRelationData, UpdateRelationErrors, UpdateRelationResponses, UpdateRoleData, UpdateRoleErrors, UpdateRoleResponses, UpdateRolesData, UpdateRolesErrors, UpdateRolesResponses, UpdateSettingData, UpdateSettingErrors, UpdateSettingResponses, UpdateSingleItemsEventData, UpdateSingleItemsEventErrors, UpdateSingleItemsEventResponses, UpdateSingleItemsWishData, UpdateSingleItemsWishErrors, UpdateSingleItemsWishListData, UpdateSingleItemsWishListErrors, UpdateSingleItemsWishListResponses, UpdateSingleItemsWishResponses, UpdateUserData, UpdateUserErrors, UpdateUserResponses, UpdateUsersData, UpdateUsersErrors, UpdateUsersResponses, UpdateWebhookData, UpdateWebhookErrors, UpdateWebhookResponses, UpdateWebhooksData, UpdateWebhooksErrors, UpdateWebhooksResponses } from './types.gen';
import { zAcceptInviteData, zAcceptInviteResponse, zClearCacheData, zCompareContentVersionData, zCompareContentVersionResponse, zCreateCollectionData, zCreateCollectionResponse, zCreateCommentData, zCreateCommentResponse, zCreateContentVersionData, zCreateContentVersionResponse, zCreateFieldData, zCreateFieldResponse, zCreateFileData, zCreateFileResponse, zCreateFlowData, zCreateFlowResponse, zCreateFolderData, zCreateFolderResponse, zCreateItemsEventData, zCreateItemsEventResponse, zCreateItemsWishData, zCreateItemsWishListData, zCreateItemsWishListResponse, zCreateItemsWishResponse, zCreateOperationData, zCreateOperationResponse, zCreatePermissionData, zCreatePermissionResponse, zCreatePresetData, zCreatePresetResponse, zCreateRelationData, zCreateRelationResponse, zCreateRoleData, zCreateRoleResponse, zCreateUserData, zCreateUserResponse, zCreateWebhookData, zCreateWebhookResponse, zDeleteCollectionData, zDeleteCommentData, zDeleteCommentsData, zDeleteContentVersionData, zDeleteContentVersionsData, zDeleteFieldData, zDeleteFileData, zDeleteFilesData, zDeleteFlowData, zDeleteFlowsData, zDeleteFolderData, zDeleteFoldersData, zDeleteItemsEventData, zDeleteItemsWishData, zDeleteItemsWishListData, zDeleteOperationData, zDeleteOperationsData, zDeletePermissionData, zDeletePermissionsData, zDeletePresetData, zDeletePresetsData, zDeleteRelationData, zDeleteRoleData, zDeleteRolesData, zDeleteSingleItemsEventData, zDeleteSingleItemsWishData, zDeleteSingleItemsWishListData, zDeleteUserData, zDeleteUsersData, zDeleteWebhookData, zDeleteWebhooksData, zExportData, zGetActivitiesData, zGetActivitiesResponse, zGetActivityData, zGetActivityResponse, zGetAssetData, zGetAssetResponse, zGetCollectionData, zGetCollectionFieldData, zGetCollectionFieldResponse, zGetCollectionFieldsData, zGetCollectionFieldsResponse, zGetCollectionResponse, zGetCollectionsData, zGetCollectionsResponse, zGetCommentData, zGetCommentResponse, zGetCommentsData, zGetCommentsResponse, zGetContentVersionData, zGetContentVersionResponse, zGetContentVersionsData, zGetContentVersionsResponse, zGetFieldsData, zGetFieldsResponse, zGetFileData, zGetFileResponse, zGetFilesData, zGetFilesResponse, zGetFlowData, zGetFlowResponse, zGetFlowsData, zGetFlowsResponse, zGetFolderData, zGetFolderResponse, zGetFoldersData, zGetFoldersResponse, zGetMeData, zGetMeResponse, zGetMyPermissionsData, zGetMyPermissionsResponse, zGetOperationData, zGetOperationResponse, zGetOperationsData, zGetOperationsResponse, zGetPermissionData, zGetPermissionResponse, zGetPermissionsData, zGetPermissionsResponse, zGetPresetData, zGetPresetResponse, zGetPresetsData, zGetPresetsResponse, zGetRelationData, zGetRelationResponse, zGetRelationsData, zGetRelationsResponse, zGetRevisionData, zGetRevisionResponse, zGetRevisionsData, zGetRevisionsResponse, zGetRoleData, zGetRoleResponse, zGetRolesData, zGetRolesResponse, zGetSettingsData, zGetSettingsResponse, zGetUserData, zGetUserResponse, zGetUsersData, zGetUsersResponse, zGetWebhookData, zGetWebhookResponse, zGetWebhooksData, zGetWebhooksResponse, zHashGenerateData, zHashGenerateResponse, zHashVerifyData, zHashVerifyResponse, zImportData, zInviteData, zInviteResponse, zListExtensionsData, zListExtensionsResponse, zLoginData, zLoginResponse, zLogoutData, zMeTfaDisableData, zMeTfaEnableData, zOauthData, zOauthProviderData, zOauthProviderResponse, zOauthResponse, zPasswordRequestData, zPasswordResetData, zPingData, zPingResponse, zPromoteContentVersionData, zPromoteContentVersionResponse, zRandomData, zRandomResponse, zReadItemsEventData, zReadItemsEventResponse, zReadItemsWishData, zReadItemsWishListData, zReadItemsWishListResponse, zReadItemsWishResponse, zReadSingleItemsEventData, zReadSingleItemsEventResponse, zReadSingleItemsWishData, zReadSingleItemsWishListData, zReadSingleItemsWishListResponse, zReadSingleItemsWishResponse, zRefreshData, zRefreshResponse, zSaveContentVersionData, zSaveContentVersionResponse, zSchemaApplyData, zSchemaApplyResponse, zSchemaDiffData, zSchemaDiffResponse, zSchemaSnapshotData, zSchemaSnapshotResponse, zServerInfoData, zServerInfoResponse, zSortData, zUpdateCollectionData, zUpdateCollectionResponse, zUpdateCommentData, zUpdateCommentResponse, zUpdateCommentsData, zUpdateCommentsResponse, zUpdateContentVersionData, zUpdateContentVersionResponse, zUpdateContentVersionsData, zUpdateContentVersionsResponse, zUpdateExtensionBundleData, zUpdateExtensionBundleResponse, zUpdateExtensionsData, zUpdateExtensionsResponse, zUpdateFieldData, zUpdateFieldResponse, zUpdateFileData, zUpdateFileResponse, zUpdateFilesData, zUpdateFilesResponse, zUpdateFlowData, zUpdateFlowResponse, zUpdateFlowsData, zUpdateFlowsResponse, zUpdateFolderData, zUpdateFolderResponse, zUpdateFoldersData, zUpdateFoldersResponse, zUpdateItemsEventData, zUpdateItemsEventResponse, zUpdateItemsWishData, zUpdateItemsWishListData, zUpdateItemsWishListResponse, zUpdateItemsWishResponse, zUpdateLastUsedPageMeData, zUpdateMeData, zUpdateMeResponse, zUpdateOperationData, zUpdateOperationResponse, zUpdateOperationsData, zUpdateOperationsResponse, zUpdatePermissionData, zUpdatePermissionResponse, zUpdatePermissionsData, zUpdatePermissionsResponse, zUpdatePresetData, zUpdatePresetResponse, zUpdatePresetsData, zUpdatePresetsResponse, zUpdateRelationData, zUpdateRelationResponse, zUpdateRoleData, zUpdateRoleResponse, zUpdateRolesData, zUpdateRolesResponse, zUpdateSettingData, zUpdateSettingResponse, zUpdateSingleItemsEventData, zUpdateSingleItemsEventResponse, zUpdateSingleItemsWishData, zUpdateSingleItemsWishListData, zUpdateSingleItemsWishListResponse, zUpdateSingleItemsWishResponse, zUpdateUserData, zUpdateUserResponse, zUpdateUsersData, zUpdateUsersResponse, zUpdateWebhookData, zUpdateWebhookResponse, zUpdateWebhooksData, zUpdateWebhooksResponse } from './zod.gen';

export type Options<TData extends TDataShape = TDataShape, ThrowOnError extends boolean = boolean> = Options2<TData, ThrowOnError> & {
    /**
     * You can provide a client instance returned by `createClient()` instead of
     * individual options. This might be also useful if you want to implement a
     * custom client.
     */
    client?: Client;
    /**
     * You can pass arbitrary values through the `meta` object. This can be
     * used to access values that aren't defined as part of the SDK function.
     */
    meta?: Record<string, unknown>;
};

/**
 * Get an Asset
 *
 * Image typed files can be dynamically resized and transformed to fit any need.
 */
export const getAsset = <ThrowOnError extends boolean = false>(options: Options<GetAssetData, ThrowOnError>) => {
    return (options.client ?? client).get<GetAssetResponses, GetAssetErrors, ThrowOnError>({
        requestValidator: async (data) => {
            return await zGetAssetData.parseAsync(data);
        },
        responseType: 'text',
        responseValidator: async (data) => {
            return await zGetAssetResponse.parseAsync(data);
        },
        url: '/assets/{id}',
        ...options
    });
};

/**
 * Retrieve a Temporary Access Token
 *
 * Retrieve a Temporary Access Token
 */
export const login = <ThrowOnError extends boolean = false>(options?: Options<LoginData, ThrowOnError>) => {
    return (options?.client ?? client).post<LoginResponses, unknown, ThrowOnError>({
        requestValidator: async (data) => {
            return await zLoginData.parseAsync(data);
        },
        responseType: 'json',
        responseValidator: async (data) => {
            return await zLoginResponse.parseAsync(data);
        },
        url: '/auth/login',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options?.headers
        }
    });
};

/**
 * Refresh Token
 *
 * Refresh a Temporary Access Token.
 */
export const refresh = <ThrowOnError extends boolean = false>(options?: Options<RefreshData, ThrowOnError>) => {
    return (options?.client ?? client).post<RefreshResponses, RefreshErrors, ThrowOnError>({
        requestValidator: async (data) => {
            return await zRefreshData.parseAsync(data);
        },
        responseType: 'json',
        responseValidator: async (data) => {
            return await zRefreshResponse.parseAsync(data);
        },
        url: '/auth/refresh',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options?.headers
        }
    });
};

/**
 * Log Out
 *
 * Log Out
 */
export const logout = <ThrowOnError extends boolean = false>(options?: Options<LogoutData, ThrowOnError>) => {
    return (options?.client ?? client).post<LogoutResponses, unknown, ThrowOnError>({
        requestValidator: async (data) => {
            return await zLogoutData.parseAsync(data);
        },
        url: '/auth/logout',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options?.headers
        }
    });
};

/**
 * Request a Password Reset
 *
 * Request a reset password email to be send.
 */
export const passwordRequest = <ThrowOnError extends boolean = false>(options?: Options<PasswordRequestData, ThrowOnError>) => {
    return (options?.client ?? client).post<unknown, PasswordRequestErrors, ThrowOnError>({
        requestValidator: async (data) => {
            return await zPasswordRequestData.parseAsync(data);
        },
        url: '/auth/password/request',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options?.headers
        }
    });
};

/**
 * Reset a Password
 *
 * The request a password reset endpoint sends an email with a link to the admin app which in turn uses this endpoint to allow the user to reset their password.
 */
export const passwordReset = <ThrowOnError extends boolean = false>(options?: Options<PasswordResetData, ThrowOnError>) => {
    return (options?.client ?? client).post<unknown, PasswordResetErrors, ThrowOnError>({
        requestValidator: async (data) => {
            return await zPasswordResetData.parseAsync(data);
        },
        url: '/auth/password/reset',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options?.headers
        }
    });
};

/**
 * List OAuth Providers
 *
 * List configured OAuth providers.
 */
export const oauth = <ThrowOnError extends boolean = false>(options?: Options<OauthData, ThrowOnError>) => {
    return (options?.client ?? client).get<OauthResponses, OauthErrors, ThrowOnError>({
        requestValidator: async (data) => {
            return await zOauthData.parseAsync(data);
        },
        responseType: 'json',
        responseValidator: async (data) => {
            return await zOauthResponse.parseAsync(data);
        },
        url: '/auth/oauth',
        ...options
    });
};

/**
 * Authenticated using an OAuth provider
 *
 * Start OAuth flow using the specified provider
 */
export const oauthProvider = <ThrowOnError extends boolean = false>(options: Options<OauthProviderData, ThrowOnError>) => {
    return (options.client ?? client).get<OauthProviderResponses, OauthProviderErrors, ThrowOnError>({
        requestValidator: async (data) => {
            return await zOauthProviderData.parseAsync(data);
        },
        responseType: 'json',
        responseValidator: async (data) => {
            return await zOauthProviderResponse.parseAsync(data);
        },
        url: '/auth/oauth/{provider}',
        ...options
    });
};

/**
 * Retrieve Schema Snapshot
 *
 * Retrieve the current schema. This endpoint is only available to admin users.
 */
export const schemaSnapshot = <ThrowOnError extends boolean = false>(options?: Options<SchemaSnapshotData, ThrowOnError>) => {
    return (options?.client ?? client).get<SchemaSnapshotResponses, SchemaSnapshotErrors, ThrowOnError>({
        requestValidator: async (data) => {
            return await zSchemaSnapshotData.parseAsync(data);
        },
        responseType: 'json',
        responseValidator: async (data) => {
            return await zSchemaSnapshotResponse.parseAsync(data);
        },
        url: '/schema/snapshot',
        ...options
    });
};

/**
 * Apply Schema Difference
 *
 * Update the instance's schema by passing the diff previously retrieved via `/schema/diff` endpoint in the JSON request body or a JSON/YAML file. This endpoint is only available to admin users.
 */
export const schemaApply = <ThrowOnError extends boolean = false>(options: Options<SchemaApplyData, ThrowOnError>) => {
    return (options.client ?? client).post<SchemaApplyResponses, SchemaApplyErrors, ThrowOnError>({
        requestValidator: async (data) => {
            return await zSchemaApplyData.parseAsync(data);
        },
        responseValidator: async (data) => {
            return await zSchemaApplyResponse.parseAsync(data);
        },
        url: '/schema/apply',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Retrieve Schema Difference
 *
 * Compare the current instance's schema against the schema snapshot in JSON request body or a JSON/YAML file and retrieve the difference. This endpoint is only available to admin users.
 */
export const schemaDiff = <ThrowOnError extends boolean = false>(options: Options<SchemaDiffData, ThrowOnError>) => {
    return (options.client ?? client).post<SchemaDiffResponses, SchemaDiffErrors, ThrowOnError>({
        requestValidator: async (data) => {
            return await zSchemaDiffData.parseAsync(data);
        },
        responseType: 'json',
        responseValidator: async (data) => {
            return await zSchemaDiffResponse.parseAsync(data);
        },
        url: '/schema/diff',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * System Info
 *
 * Perform a system status check and return the options.
 */
export const serverInfo = <ThrowOnError extends boolean = false>(options: Options<ServerInfoData, ThrowOnError>) => {
    return (options.client ?? client).get<ServerInfoResponses, ServerInfoErrors, ThrowOnError>({
        requestValidator: async (data) => {
            return await zServerInfoData.parseAsync(data);
        },
        responseType: 'json',
        responseValidator: async (data) => {
            return await zServerInfoResponse.parseAsync(data);
        },
        url: '/server/info',
        ...options
    });
};

/**
 * Ping
 *
 * Ping, pong. Ping.. pong.
 */
export const ping = <ThrowOnError extends boolean = false>(options?: Options<PingData, ThrowOnError>) => {
    return (options?.client ?? client).get<PingResponses, unknown, ThrowOnError>({
        requestValidator: async (data) => {
            return await zPingData.parseAsync(data);
        },
        responseType: 'blob',
        responseValidator: async (data) => {
            return await zPingResponse.parseAsync(data);
        },
        url: '/server/ping',
        ...options
    });
};

/**
 * Hash a string
 *
 * Generate a hash for a given string.
 */
export const hashGenerate = <ThrowOnError extends boolean = false>(options?: Options<HashGenerateData, ThrowOnError>) => {
    return (options?.client ?? client).post<HashGenerateResponses, unknown, ThrowOnError>({
        requestValidator: async (data) => {
            return await zHashGenerateData.parseAsync(data);
        },
        responseType: 'json',
        responseValidator: async (data) => {
            return await zHashGenerateResponse.parseAsync(data);
        },
        url: '/utils/hash/generate',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options?.headers
        }
    });
};

/**
 * Hash a string
 *
 * Generate a hash for a given string.
 */
export const hashVerify = <ThrowOnError extends boolean = false>(options?: Options<HashVerifyData, ThrowOnError>) => {
    return (options?.client ?? client).post<HashVerifyResponses, unknown, ThrowOnError>({
        requestValidator: async (data) => {
            return await zHashVerifyData.parseAsync(data);
        },
        responseType: 'json',
        responseValidator: async (data) => {
            return await zHashVerifyResponse.parseAsync(data);
        },
        url: '/utils/hash/verify',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options?.headers
        }
    });
};

/**
 * Sort Items
 *
 * Re-sort items in collection based on start and to value of item
 */
export const sort = <ThrowOnError extends boolean = false>(options: Options<SortData, ThrowOnError>) => {
    return (options.client ?? client).post<SortResponses, unknown, ThrowOnError>({
        requestValidator: async (data) => {
            return await zSortData.parseAsync(data);
        },
        url: '/utils/sort/{collection}',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Import Items
 *
 * Import multiple records from a JSON or CSV file into a collection.
 */
export const import_ = <ThrowOnError extends boolean = false>(options: Options<ImportData, ThrowOnError>) => {
    return (options.client ?? client).post<ImportResponses, unknown, ThrowOnError>({
        ...formDataBodySerializer,
        requestValidator: async (data) => {
            return await zImportData.parseAsync(data);
        },
        url: '/utils/import/{collection}',
        ...options,
        headers: {
            'Content-Type': null,
            ...options.headers
        }
    });
};

/**
 * Export Items
 *
 * Export a larger data set to a file in the File Library
 */
export const export_ = <ThrowOnError extends boolean = false>(options: Options<ExportData, ThrowOnError>) => {
    return (options.client ?? client).post<ExportResponses, unknown, ThrowOnError>({
        requestValidator: async (data) => {
            return await zExportData.parseAsync(data);
        },
        url: '/utils/export/{collection}',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Clear Cache
 *
 * Resets both the data and schema cache of Directus.
 */
export const clearCache = <ThrowOnError extends boolean = false>(options?: Options<ClearCacheData, ThrowOnError>) => {
    return (options?.client ?? client).post<ClearCacheResponses, unknown, ThrowOnError>({
        requestValidator: async (data) => {
            return await zClearCacheData.parseAsync(data);
        },
        url: '/utils/cache/clear',
        ...options
    });
};

/**
 * Get a Random String
 *
 * Returns a random string of given length.
 */
export const random = <ThrowOnError extends boolean = false>(options?: Options<RandomData, ThrowOnError>) => {
    return (options?.client ?? client).get<RandomResponses, unknown, ThrowOnError>({
        requestValidator: async (data) => {
            return await zRandomData.parseAsync(data);
        },
        responseType: 'json',
        responseValidator: async (data) => {
            return await zRandomResponse.parseAsync(data);
        },
        url: '/utils/random/string',
        ...options
    });
};

/**
 * Delete Multiple Comments
 *
 * Delete multiple existing comments.
 */
export const deleteComments = <ThrowOnError extends boolean = false>(options?: Options<DeleteCommentsData, ThrowOnError>) => {
    return (options?.client ?? client).delete<DeleteCommentsResponses, DeleteCommentsErrors, ThrowOnError>({
        requestValidator: async (data) => {
            return await zDeleteCommentsData.parseAsync(data);
        },
        url: '/comments',
        ...options
    });
};

/**
 * List Comments
 *
 * List the comments.
 */
export const getComments = <ThrowOnError extends boolean = false>(options?: Options<GetCommentsData, ThrowOnError>) => {
    return (options?.client ?? client).get<GetCommentsResponses, GetCommentsErrors, ThrowOnError>({
        querySerializer: {
            parameters: {
                fields: {
                    array: {
                        explode: false
                    }
                },
                sort: {
                    array: {
                        explode: false
                    }
                },
                filter: {
                    object: {
                        style: 'form'
                    }
                }
            }
        },
        requestValidator: async (data) => {
            return await zGetCommentsData.parseAsync(data);
        },
        responseType: 'json',
        responseValidator: async (data) => {
            return await zGetCommentsResponse.parseAsync(data);
        },
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/comments',
        ...options
    });
};

/**
 * Update Multiple Comments
 *
 * Update multiple comments at the same time.
 */
export const updateComments = <ThrowOnError extends boolean = false>(options?: Options<UpdateCommentsData, ThrowOnError>) => {
    return (options?.client ?? client).patch<UpdateCommentsResponses, UpdateCommentsErrors, ThrowOnError>({
        querySerializer: {
            parameters: {
                fields: {
                    array: {
                        explode: false
                    }
                },
                sort: {
                    array: {
                        explode: false
                    }
                },
                filter: {
                    object: {
                        style: 'form'
                    }
                }
            }
        },
        requestValidator: async (data) => {
            return await zUpdateCommentsData.parseAsync(data);
        },
        responseType: 'json',
        responseValidator: async (data) => {
            return await zUpdateCommentsResponse.parseAsync(data);
        },
        url: '/comments',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options?.headers
        }
    });
};

/**
 * Create a Comment
 *
 * Create a new comment.
 */
export const createComment = <ThrowOnError extends boolean = false>(options?: Options<CreateCommentData, ThrowOnError>) => {
    return (options?.client ?? client).post<CreateCommentResponses, CreateCommentErrors, ThrowOnError>({
        querySerializer: {
            parameters: {
                fields: {
                    array: {
                        explode: false
                    }
                }
            }
        },
        requestValidator: async (data) => {
            return await zCreateCommentData.parseAsync(data);
        },
        responseType: 'json',
        responseValidator: async (data) => {
            return await zCreateCommentResponse.parseAsync(data);
        },
        url: '/comments',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options?.headers
        }
    });
};

/**
 * Delete a Comment
 *
 * Delete an existing comment.
 */
export const deleteComment = <ThrowOnError extends boolean = false>(options?: Options<DeleteCommentData, ThrowOnError>) => {
    return (options?.client ?? client).delete<DeleteCommentResponses, DeleteCommentErrors, ThrowOnError>({
        requestValidator: async (data) => {
            return await zDeleteCommentData.parseAsync(data);
        },
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/comments/{id}',
        ...options
    });
};

/**
 * Retrieve a Comment
 *
 * Retrieve a single comment by unique identifier.
 */
export const getComment = <ThrowOnError extends boolean = false>(options?: Options<GetCommentData, ThrowOnError>) => {
    return (options?.client ?? client).get<GetCommentResponses, GetCommentErrors, ThrowOnError>({
        querySerializer: {
            parameters: {
                fields: {
                    array: {
                        explode: false
                    }
                }
            }
        },
        requestValidator: async (data) => {
            return await zGetCommentData.parseAsync(data);
        },
        responseType: 'json',
        responseValidator: async (data) => {
            return await zGetCommentResponse.parseAsync(data);
        },
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/comments/{id}',
        ...options
    });
};

/**
 * Update a Comment
 *
 * Update an existing comment.
 */
export const updateComment = <ThrowOnError extends boolean = false>(options?: Options<UpdateCommentData, ThrowOnError>) => {
    return (options?.client ?? client).patch<UpdateCommentResponses, UpdateCommentErrors, ThrowOnError>({
        querySerializer: {
            parameters: {
                fields: {
                    array: {
                        explode: false
                    }
                }
            }
        },
        requestValidator: async (data) => {
            return await zUpdateCommentData.parseAsync(data);
        },
        responseType: 'json',
        responseValidator: async (data) => {
            return await zUpdateCommentResponse.parseAsync(data);
        },
        url: '/comments/{id}',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options?.headers
        }
    });
};

/**
 * Delete Multiple Folders
 *
 * Delete multiple existing folders.
 */
export const deleteFolders = <ThrowOnError extends boolean = false>(options?: Options<DeleteFoldersData, ThrowOnError>) => {
    return (options?.client ?? client).delete<DeleteFoldersResponses, DeleteFoldersErrors, ThrowOnError>({
        requestValidator: async (data) => {
            return await zDeleteFoldersData.parseAsync(data);
        },
        url: '/folders',
        ...options
    });
};

/**
 * List Folders
 *
 * List the folders.
 */
export const getFolders = <ThrowOnError extends boolean = false>(options?: Options<GetFoldersData, ThrowOnError>) => {
    return (options?.client ?? client).get<GetFoldersResponses, GetFoldersErrors, ThrowOnError>({
        querySerializer: {
            parameters: {
                fields: {
                    array: {
                        explode: false
                    }
                },
                sort: {
                    array: {
                        explode: false
                    }
                },
                filter: {
                    object: {
                        style: 'form'
                    }
                }
            }
        },
        requestValidator: async (data) => {
            return await zGetFoldersData.parseAsync(data);
        },
        responseType: 'json',
        responseValidator: async (data) => {
            return await zGetFoldersResponse.parseAsync(data);
        },
        url: '/folders',
        ...options
    });
};

/**
 * Update Multiple Folders
 *
 * Update multiple folders at the same time.
 */
export const updateFolders = <ThrowOnError extends boolean = false>(options?: Options<UpdateFoldersData, ThrowOnError>) => {
    return (options?.client ?? client).patch<UpdateFoldersResponses, UpdateFoldersErrors, ThrowOnError>({
        querySerializer: {
            parameters: {
                fields: {
                    array: {
                        explode: false
                    }
                },
                sort: {
                    array: {
                        explode: false
                    }
                },
                filter: {
                    object: {
                        style: 'form'
                    }
                }
            }
        },
        requestValidator: async (data) => {
            return await zUpdateFoldersData.parseAsync(data);
        },
        responseType: 'json',
        responseValidator: async (data) => {
            return await zUpdateFoldersResponse.parseAsync(data);
        },
        url: '/folders',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options?.headers
        }
    });
};

/**
 * Create a Folder
 *
 * Create a new folder.
 */
export const createFolder = <ThrowOnError extends boolean = false>(options?: Options<CreateFolderData, ThrowOnError>) => {
    return (options?.client ?? client).post<CreateFolderResponses, CreateFolderErrors, ThrowOnError>({
        querySerializer: {
            parameters: {
                fields: {
                    array: {
                        explode: false
                    }
                }
            }
        },
        requestValidator: async (data) => {
            return await zCreateFolderData.parseAsync(data);
        },
        responseType: 'json',
        responseValidator: async (data) => {
            return await zCreateFolderResponse.parseAsync(data);
        },
        url: '/folders',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options?.headers
        }
    });
};

/**
 * Delete a Folder
 *
 * Delete an existing folder
 */
export const deleteFolder = <ThrowOnError extends boolean = false>(options: Options<DeleteFolderData, ThrowOnError>) => {
    return (options.client ?? client).delete<DeleteFolderResponses, DeleteFolderErrors, ThrowOnError>({
        requestValidator: async (data) => {
            return await zDeleteFolderData.parseAsync(data);
        },
        url: '/folders/{id}',
        ...options
    });
};

/**
 * Retrieve a Folder
 *
 * Retrieve a single folder by unique identifier.
 */
export const getFolder = <ThrowOnError extends boolean = false>(options: Options<GetFolderData, ThrowOnError>) => {
    return (options.client ?? client).get<GetFolderResponses, GetFolderErrors, ThrowOnError>({
        querySerializer: {
            parameters: {
                fields: {
                    array: {
                        explode: false
                    }
                }
            }
        },
        requestValidator: async (data) => {
            return await zGetFolderData.parseAsync(data);
        },
        responseType: 'json',
        responseValidator: async (data) => {
            return await zGetFolderResponse.parseAsync(data);
        },
        url: '/folders/{id}',
        ...options
    });
};

/**
 * Update a Folder
 *
 * Update an existing folder
 */
export const updateFolder = <ThrowOnError extends boolean = false>(options: Options<UpdateFolderData, ThrowOnError>) => {
    return (options.client ?? client).patch<UpdateFolderResponses, UpdateFolderErrors, ThrowOnError>({
        querySerializer: {
            parameters: {
                fields: {
                    array: {
                        explode: false
                    }
                }
            }
        },
        requestValidator: async (data) => {
            return await zUpdateFolderData.parseAsync(data);
        },
        responseType: 'json',
        responseValidator: async (data) => {
            return await zUpdateFolderResponse.parseAsync(data);
        },
        url: '/folders/{id}',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * List Extensions
 *
 * List the installed extensions and their configuration in the project.
 */
export const listExtensions = <ThrowOnError extends boolean = false>(options?: Options<ListExtensionsData, ThrowOnError>) => {
    return (options?.client ?? client).get<ListExtensionsResponses, ListExtensionsErrors, ThrowOnError>({
        requestValidator: async (data) => {
            return await zListExtensionsData.parseAsync(data);
        },
        responseType: 'json',
        responseValidator: async (data) => {
            return await zListExtensionsResponse.parseAsync(data);
        },
        url: '/extensions',
        ...options
    });
};

/**
 * Update an Extension
 *
 * Update an existing extension.
 */
export const updateExtensions = <ThrowOnError extends boolean = false>(options: Options<UpdateExtensionsData, ThrowOnError>) => {
    return (options.client ?? client).patch<UpdateExtensionsResponses, UpdateExtensionsErrors, ThrowOnError>({
        requestValidator: async (data) => {
            return await zUpdateExtensionsData.parseAsync(data);
        },
        responseType: 'json',
        responseValidator: async (data) => {
            return await zUpdateExtensionsResponse.parseAsync(data);
        },
        url: '/extensions/{name}',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Update an Extension
 *
 * Update an existing extension.
 */
export const updateExtensionBundle = <ThrowOnError extends boolean = false>(options: Options<UpdateExtensionBundleData, ThrowOnError>) => {
    return (options.client ?? client).patch<UpdateExtensionBundleResponses, UpdateExtensionBundleErrors, ThrowOnError>({
        requestValidator: async (data) => {
            return await zUpdateExtensionBundleData.parseAsync(data);
        },
        responseType: 'json',
        responseValidator: async (data) => {
            return await zUpdateExtensionBundleResponse.parseAsync(data);
        },
        url: '/extensions/{bundle}/{name}',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * List All Fields
 *
 * Returns a list of the fields available in the project.
 */
export const getFields = <ThrowOnError extends boolean = false>(options?: Options<GetFieldsData, ThrowOnError>) => {
    return (options?.client ?? client).get<GetFieldsResponses, GetFieldsErrors, ThrowOnError>({
        querySerializer: {
            parameters: {
                sort: {
                    array: {
                        explode: false
                    }
                }
            }
        },
        requestValidator: async (data) => {
            return await zGetFieldsData.parseAsync(data);
        },
        responseType: 'json',
        responseValidator: async (data) => {
            return await zGetFieldsResponse.parseAsync(data);
        },
        url: '/fields',
        ...options
    });
};

/**
 * List Fields in Collection
 *
 * Returns a list of the fields available in the given collection.
 */
export const getCollectionFields = <ThrowOnError extends boolean = false>(options: Options<GetCollectionFieldsData, ThrowOnError>) => {
    return (options.client ?? client).get<GetCollectionFieldsResponses, GetCollectionFieldsErrors, ThrowOnError>({
        querySerializer: {
            parameters: {
                sort: {
                    array: {
                        explode: false
                    }
                }
            }
        },
        requestValidator: async (data) => {
            return await zGetCollectionFieldsData.parseAsync(data);
        },
        responseType: 'json',
        responseValidator: async (data) => {
            return await zGetCollectionFieldsResponse.parseAsync(data);
        },
        url: '/fields/{collection}',
        ...options
    });
};

/**
 * Create Field in Collection
 *
 * Create a new field in a given collection.
 */
export const createField = <ThrowOnError extends boolean = false>(options: Options<CreateFieldData, ThrowOnError>) => {
    return (options.client ?? client).post<CreateFieldResponses, CreateFieldErrors, ThrowOnError>({
        requestValidator: async (data) => {
            return await zCreateFieldData.parseAsync(data);
        },
        responseType: 'json',
        responseValidator: async (data) => {
            return await zCreateFieldResponse.parseAsync(data);
        },
        url: '/fields/{collection}',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Delete a Field
 *
 * Delete an existing field.
 */
export const deleteField = <ThrowOnError extends boolean = false>(options: Options<DeleteFieldData, ThrowOnError>) => {
    return (options.client ?? client).delete<DeleteFieldResponses, DeleteFieldErrors, ThrowOnError>({
        requestValidator: async (data) => {
            return await zDeleteFieldData.parseAsync(data);
        },
        url: '/fields/{collection}/{id}',
        ...options
    });
};

/**
 * Retrieve a Field
 *
 * Retrieves the details of a single field in a given collection.
 */
export const getCollectionField = <ThrowOnError extends boolean = false>(options: Options<GetCollectionFieldData, ThrowOnError>) => {
    return (options.client ?? client).get<GetCollectionFieldResponses, GetCollectionFieldErrors, ThrowOnError>({
        requestValidator: async (data) => {
            return await zGetCollectionFieldData.parseAsync(data);
        },
        responseType: 'json',
        responseValidator: async (data) => {
            return await zGetCollectionFieldResponse.parseAsync(data);
        },
        url: '/fields/{collection}/{id}',
        ...options
    });
};

/**
 * Update a Field
 *
 * Update an existing field.
 */
export const updateField = <ThrowOnError extends boolean = false>(options: Options<UpdateFieldData, ThrowOnError>) => {
    return (options.client ?? client).patch<UpdateFieldResponses, UpdateFieldErrors, ThrowOnError>({
        requestValidator: async (data) => {
            return await zUpdateFieldData.parseAsync(data);
        },
        responseType: 'json',
        responseValidator: async (data) => {
            return await zUpdateFieldResponse.parseAsync(data);
        },
        url: '/fields/{collection}/{id}',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Delete Multiple Flows
 *
 * Delete multiple existing flows.
 */
export const deleteFlows = <ThrowOnError extends boolean = false>(options?: Options<DeleteFlowsData, ThrowOnError>) => {
    return (options?.client ?? client).delete<DeleteFlowsResponses, DeleteFlowsErrors, ThrowOnError>({
        requestValidator: async (data) => {
            return await zDeleteFlowsData.parseAsync(data);
        },
        url: '/flows',
        ...options
    });
};

/**
 * List Flows
 *
 * Get all flows.
 */
export const getFlows = <ThrowOnError extends boolean = false>(options?: Options<GetFlowsData, ThrowOnError>) => {
    return (options?.client ?? client).get<GetFlowsResponses, GetFlowsErrors, ThrowOnError>({
        requestValidator: async (data) => {
            return await zGetFlowsData.parseAsync(data);
        },
        responseType: 'json',
        responseValidator: async (data) => {
            return await zGetFlowsResponse.parseAsync(data);
        },
        url: '/flows',
        ...options
    });
};

/**
 * Update Multiple Flows
 *
 * Update multiple flows at the same time.
 */
export const updateFlows = <ThrowOnError extends boolean = false>(options?: Options<UpdateFlowsData, ThrowOnError>) => {
    return (options?.client ?? client).patch<UpdateFlowsResponses, UpdateFlowsErrors, ThrowOnError>({
        querySerializer: {
            parameters: {
                fields: {
                    array: {
                        explode: false
                    }
                },
                sort: {
                    array: {
                        explode: false
                    }
                },
                filter: {
                    object: {
                        style: 'form'
                    }
                }
            }
        },
        requestValidator: async (data) => {
            return await zUpdateFlowsData.parseAsync(data);
        },
        responseType: 'json',
        responseValidator: async (data) => {
            return await zUpdateFlowsResponse.parseAsync(data);
        },
        url: '/flows',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options?.headers
        }
    });
};

/**
 * Create a Flow
 *
 * Create a new flow.
 */
export const createFlow = <ThrowOnError extends boolean = false>(options?: Options<CreateFlowData, ThrowOnError>) => {
    return (options?.client ?? client).post<CreateFlowResponses, CreateFlowErrors, ThrowOnError>({
        querySerializer: {
            parameters: {
                fields: {
                    array: {
                        explode: false
                    }
                }
            }
        },
        requestValidator: async (data) => {
            return await zCreateFlowData.parseAsync(data);
        },
        responseType: 'json',
        responseValidator: async (data) => {
            return await zCreateFlowResponse.parseAsync(data);
        },
        url: '/flows',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options?.headers
        }
    });
};

/**
 * Delete a Flow
 *
 * Delete an existing flow
 */
export const deleteFlow = <ThrowOnError extends boolean = false>(options: Options<DeleteFlowData, ThrowOnError>) => {
    return (options.client ?? client).delete<DeleteFlowResponses, DeleteFlowErrors, ThrowOnError>({
        requestValidator: async (data) => {
            return await zDeleteFlowData.parseAsync(data);
        },
        url: '/flows/{id}',
        ...options
    });
};

/**
 * Retrieve a Flow
 *
 * Retrieve a single flow by unique identifier.
 */
export const getFlow = <ThrowOnError extends boolean = false>(options: Options<GetFlowData, ThrowOnError>) => {
    return (options.client ?? client).get<GetFlowResponses, GetFlowErrors, ThrowOnError>({
        requestValidator: async (data) => {
            return await zGetFlowData.parseAsync(data);
        },
        responseType: 'json',
        responseValidator: async (data) => {
            return await zGetFlowResponse.parseAsync(data);
        },
        url: '/flows/{id}',
        ...options
    });
};

/**
 * Update a Flow
 *
 * Update an existing flow
 */
export const updateFlow = <ThrowOnError extends boolean = false>(options: Options<UpdateFlowData, ThrowOnError>) => {
    return (options.client ?? client).patch<UpdateFlowResponses, UpdateFlowErrors, ThrowOnError>({
        querySerializer: {
            parameters: {
                fields: {
                    array: {
                        explode: false
                    }
                }
            }
        },
        requestValidator: async (data) => {
            return await zUpdateFlowData.parseAsync(data);
        },
        responseType: 'json',
        responseValidator: async (data) => {
            return await zUpdateFlowResponse.parseAsync(data);
        },
        url: '/flows/{id}',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Delete Multiple Operations
 *
 * Delete multiple existing operations.
 */
export const deleteOperations = <ThrowOnError extends boolean = false>(options?: Options<DeleteOperationsData, ThrowOnError>) => {
    return (options?.client ?? client).delete<DeleteOperationsResponses, DeleteOperationsErrors, ThrowOnError>({
        requestValidator: async (data) => {
            return await zDeleteOperationsData.parseAsync(data);
        },
        url: '/operations',
        ...options
    });
};

/**
 * List Operations
 *
 * Get all operations.
 */
export const getOperations = <ThrowOnError extends boolean = false>(options?: Options<GetOperationsData, ThrowOnError>) => {
    return (options?.client ?? client).get<GetOperationsResponses, GetOperationsErrors, ThrowOnError>({
        requestValidator: async (data) => {
            return await zGetOperationsData.parseAsync(data);
        },
        responseType: 'json',
        responseValidator: async (data) => {
            return await zGetOperationsResponse.parseAsync(data);
        },
        url: '/operations',
        ...options
    });
};

/**
 * Update Multiple Operations
 *
 * Update multiple operations at the same time.
 */
export const updateOperations = <ThrowOnError extends boolean = false>(options?: Options<UpdateOperationsData, ThrowOnError>) => {
    return (options?.client ?? client).patch<UpdateOperationsResponses, UpdateOperationsErrors, ThrowOnError>({
        querySerializer: {
            parameters: {
                fields: {
                    array: {
                        explode: false
                    }
                },
                sort: {
                    array: {
                        explode: false
                    }
                },
                filter: {
                    object: {
                        style: 'form'
                    }
                }
            }
        },
        requestValidator: async (data) => {
            return await zUpdateOperationsData.parseAsync(data);
        },
        responseType: 'json',
        responseValidator: async (data) => {
            return await zUpdateOperationsResponse.parseAsync(data);
        },
        url: '/operations',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options?.headers
        }
    });
};

/**
 * Create an Operation
 *
 * Create a new operation.
 */
export const createOperation = <ThrowOnError extends boolean = false>(options?: Options<CreateOperationData, ThrowOnError>) => {
    return (options?.client ?? client).post<CreateOperationResponses, CreateOperationErrors, ThrowOnError>({
        querySerializer: {
            parameters: {
                fields: {
                    array: {
                        explode: false
                    }
                }
            }
        },
        requestValidator: async (data) => {
            return await zCreateOperationData.parseAsync(data);
        },
        responseType: 'json',
        responseValidator: async (data) => {
            return await zCreateOperationResponse.parseAsync(data);
        },
        url: '/operations',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options?.headers
        }
    });
};

/**
 * Delete an Operation
 *
 * Delete an existing operation
 */
export const deleteOperation = <ThrowOnError extends boolean = false>(options: Options<DeleteOperationData, ThrowOnError>) => {
    return (options.client ?? client).delete<DeleteOperationResponses, DeleteOperationErrors, ThrowOnError>({
        requestValidator: async (data) => {
            return await zDeleteOperationData.parseAsync(data);
        },
        url: '/operations/{id}',
        ...options
    });
};

/**
 * Retrieve an Operation
 *
 * Retrieve a single operation by unique identifier.
 */
export const getOperation = <ThrowOnError extends boolean = false>(options: Options<GetOperationData, ThrowOnError>) => {
    return (options.client ?? client).get<GetOperationResponses, GetOperationErrors, ThrowOnError>({
        requestValidator: async (data) => {
            return await zGetOperationData.parseAsync(data);
        },
        responseType: 'json',
        responseValidator: async (data) => {
            return await zGetOperationResponse.parseAsync(data);
        },
        url: '/operations/{id}',
        ...options
    });
};

/**
 * Update an Operation
 *
 * Update an existing operation
 */
export const updateOperation = <ThrowOnError extends boolean = false>(options: Options<UpdateOperationData, ThrowOnError>) => {
    return (options.client ?? client).patch<UpdateOperationResponses, UpdateOperationErrors, ThrowOnError>({
        querySerializer: {
            parameters: {
                fields: {
                    array: {
                        explode: false
                    }
                }
            }
        },
        requestValidator: async (data) => {
            return await zUpdateOperationData.parseAsync(data);
        },
        responseType: 'json',
        responseValidator: async (data) => {
            return await zUpdateOperationResponse.parseAsync(data);
        },
        url: '/operations/{id}',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * List Activity Actions
 *
 * Returns a list of activity actions.
 */
export const getActivities = <ThrowOnError extends boolean = false>(options?: Options<GetActivitiesData, ThrowOnError>) => {
    return (options?.client ?? client).get<GetActivitiesResponses, GetActivitiesErrors, ThrowOnError>({
        querySerializer: {
            parameters: {
                fields: {
                    array: {
                        explode: false
                    }
                },
                sort: {
                    array: {
                        explode: false
                    }
                },
                filter: {
                    object: {
                        style: 'form'
                    }
                }
            }
        },
        requestValidator: async (data) => {
            return await zGetActivitiesData.parseAsync(data);
        },
        responseType: 'json',
        responseValidator: async (data) => {
            return await zGetActivitiesResponse.parseAsync(data);
        },
        url: '/activity',
        ...options
    });
};

/**
 * Retrieve an Activity Action
 *
 * Retrieves the details of an existing activity action. Provide the primary key of the activity action and Directus will return the corresponding information.
 */
export const getActivity = <ThrowOnError extends boolean = false>(options: Options<GetActivityData, ThrowOnError>) => {
    return (options.client ?? client).get<GetActivityResponses, GetActivityErrors, ThrowOnError>({
        querySerializer: {
            parameters: {
                fields: {
                    array: {
                        explode: false
                    }
                }
            }
        },
        requestValidator: async (data) => {
            return await zGetActivityData.parseAsync(data);
        },
        responseType: 'json',
        responseValidator: async (data) => {
            return await zGetActivityResponse.parseAsync(data);
        },
        url: '/activity/{id}',
        ...options
    });
};

/**
 * List Collections
 *
 * Returns a list of the collections available in the project.
 */
export const getCollections = <ThrowOnError extends boolean = false>(options?: Options<GetCollectionsData, ThrowOnError>) => {
    return (options?.client ?? client).get<GetCollectionsResponses, GetCollectionsErrors, ThrowOnError>({
        requestValidator: async (data) => {
            return await zGetCollectionsData.parseAsync(data);
        },
        responseType: 'json',
        responseValidator: async (data) => {
            return await zGetCollectionsResponse.parseAsync(data);
        },
        url: '/collections',
        ...options
    });
};

/**
 * Create a Collection
 *
 * Create a new collection in Directus.
 */
export const createCollection = <ThrowOnError extends boolean = false>(options?: Options<CreateCollectionData, ThrowOnError>) => {
    return (options?.client ?? client).post<CreateCollectionResponses, CreateCollectionErrors, ThrowOnError>({
        requestValidator: async (data) => {
            return await zCreateCollectionData.parseAsync(data);
        },
        responseType: 'json',
        responseValidator: async (data) => {
            return await zCreateCollectionResponse.parseAsync(data);
        },
        url: '/collections',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options?.headers
        }
    });
};

/**
 * Delete a Collection
 *
 * Delete an existing collection. Warning: This will delete the whole collection, including the items within. Proceed with caution.
 */
export const deleteCollection = <ThrowOnError extends boolean = false>(options: Options<DeleteCollectionData, ThrowOnError>) => {
    return (options.client ?? client).delete<DeleteCollectionResponses, DeleteCollectionErrors, ThrowOnError>({
        requestValidator: async (data) => {
            return await zDeleteCollectionData.parseAsync(data);
        },
        url: '/collections/{id}',
        ...options
    });
};

/**
 * Retrieve a Collection
 *
 * Retrieves the details of a single collection.
 */
export const getCollection = <ThrowOnError extends boolean = false>(options: Options<GetCollectionData, ThrowOnError>) => {
    return (options.client ?? client).get<GetCollectionResponses, GetCollectionErrors, ThrowOnError>({
        requestValidator: async (data) => {
            return await zGetCollectionData.parseAsync(data);
        },
        responseType: 'json',
        responseValidator: async (data) => {
            return await zGetCollectionResponse.parseAsync(data);
        },
        url: '/collections/{id}',
        ...options
    });
};

/**
 * Update a Collection
 *
 * Update an existing collection.
 */
export const updateCollection = <ThrowOnError extends boolean = false>(options: Options<UpdateCollectionData, ThrowOnError>) => {
    return (options.client ?? client).patch<UpdateCollectionResponses, UpdateCollectionErrors, ThrowOnError>({
        requestValidator: async (data) => {
            return await zUpdateCollectionData.parseAsync(data);
        },
        responseType: 'json',
        responseValidator: async (data) => {
            return await zUpdateCollectionResponse.parseAsync(data);
        },
        url: '/collections/{id}',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Delete Multiple Permissions
 *
 * Delete multiple existing permissions.
 */
export const deletePermissions = <ThrowOnError extends boolean = false>(options?: Options<DeletePermissionsData, ThrowOnError>) => {
    return (options?.client ?? client).delete<DeletePermissionsResponses, DeletePermissionsErrors, ThrowOnError>({
        requestValidator: async (data) => {
            return await zDeletePermissionsData.parseAsync(data);
        },
        url: '/permissions',
        ...options
    });
};

/**
 * List Permissions
 *
 * List all permissions.
 */
export const getPermissions = <ThrowOnError extends boolean = false>(options?: Options<GetPermissionsData, ThrowOnError>) => {
    return (options?.client ?? client).get<GetPermissionsResponses, GetPermissionsErrors, ThrowOnError>({
        querySerializer: {
            parameters: {
                fields: {
                    array: {
                        explode: false
                    }
                },
                sort: {
                    array: {
                        explode: false
                    }
                },
                filter: {
                    object: {
                        style: 'form'
                    }
                }
            }
        },
        requestValidator: async (data) => {
            return await zGetPermissionsData.parseAsync(data);
        },
        responseType: 'json',
        responseValidator: async (data) => {
            return await zGetPermissionsResponse.parseAsync(data);
        },
        url: '/permissions',
        ...options
    });
};

/**
 * Update Multiple Permissions
 *
 * Update multiple permissions at the same time.
 */
export const updatePermissions = <ThrowOnError extends boolean = false>(options?: Options<UpdatePermissionsData, ThrowOnError>) => {
    return (options?.client ?? client).patch<UpdatePermissionsResponses, UpdatePermissionsErrors, ThrowOnError>({
        querySerializer: {
            parameters: {
                fields: {
                    array: {
                        explode: false
                    }
                },
                sort: {
                    array: {
                        explode: false
                    }
                },
                filter: {
                    object: {
                        style: 'form'
                    }
                }
            }
        },
        requestValidator: async (data) => {
            return await zUpdatePermissionsData.parseAsync(data);
        },
        responseType: 'json',
        responseValidator: async (data) => {
            return await zUpdatePermissionsResponse.parseAsync(data);
        },
        url: '/permissions',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options?.headers
        }
    });
};

/**
 * Create a Permission
 *
 * Create a new permission.
 */
export const createPermission = <ThrowOnError extends boolean = false>(options?: Options<CreatePermissionData, ThrowOnError>) => {
    return (options?.client ?? client).post<CreatePermissionResponses, CreatePermissionErrors, ThrowOnError>({
        requestValidator: async (data) => {
            return await zCreatePermissionData.parseAsync(data);
        },
        responseType: 'json',
        responseValidator: async (data) => {
            return await zCreatePermissionResponse.parseAsync(data);
        },
        url: '/permissions',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options?.headers
        }
    });
};

/**
 * List My Permissions
 *
 * List the permissions that apply to the current user.
 */
export const getMyPermissions = <ThrowOnError extends boolean = false>(options?: Options<GetMyPermissionsData, ThrowOnError>) => {
    return (options?.client ?? client).get<GetMyPermissionsResponses, GetMyPermissionsErrors, ThrowOnError>({
        requestValidator: async (data) => {
            return await zGetMyPermissionsData.parseAsync(data);
        },
        responseType: 'json',
        responseValidator: async (data) => {
            return await zGetMyPermissionsResponse.parseAsync(data);
        },
        url: '/permissions/me',
        ...options
    });
};

/**
 * Delete a Permission
 *
 * Delete an existing permission
 */
export const deletePermission = <ThrowOnError extends boolean = false>(options: Options<DeletePermissionData, ThrowOnError>) => {
    return (options.client ?? client).delete<DeletePermissionResponses, DeletePermissionErrors, ThrowOnError>({
        requestValidator: async (data) => {
            return await zDeletePermissionData.parseAsync(data);
        },
        url: '/permissions/{id}',
        ...options
    });
};

/**
 * Retrieve a Permission
 *
 * Retrieve a single permissions object by unique identifier.
 */
export const getPermission = <ThrowOnError extends boolean = false>(options: Options<GetPermissionData, ThrowOnError>) => {
    return (options.client ?? client).get<GetPermissionResponses, GetPermissionErrors, ThrowOnError>({
        querySerializer: {
            parameters: {
                fields: {
                    array: {
                        explode: false
                    }
                }
            }
        },
        requestValidator: async (data) => {
            return await zGetPermissionData.parseAsync(data);
        },
        responseType: 'json',
        responseValidator: async (data) => {
            return await zGetPermissionResponse.parseAsync(data);
        },
        url: '/permissions/{id}',
        ...options
    });
};

/**
 * Update a Permission
 *
 * Update an existing permission
 */
export const updatePermission = <ThrowOnError extends boolean = false>(options: Options<UpdatePermissionData, ThrowOnError>) => {
    return (options.client ?? client).patch<UpdatePermissionResponses, UpdatePermissionErrors, ThrowOnError>({
        requestValidator: async (data) => {
            return await zUpdatePermissionData.parseAsync(data);
        },
        responseType: 'json',
        responseValidator: async (data) => {
            return await zUpdatePermissionResponse.parseAsync(data);
        },
        url: '/permissions/{id}',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * List Relations
 *
 * List the relations.
 */
export const getRelations = <ThrowOnError extends boolean = false>(options?: Options<GetRelationsData, ThrowOnError>) => {
    return (options?.client ?? client).get<GetRelationsResponses, GetRelationsErrors, ThrowOnError>({
        querySerializer: {
            parameters: {
                fields: {
                    array: {
                        explode: false
                    }
                },
                sort: {
                    array: {
                        explode: false
                    }
                },
                filter: {
                    object: {
                        style: 'form'
                    }
                }
            }
        },
        requestValidator: async (data) => {
            return await zGetRelationsData.parseAsync(data);
        },
        responseType: 'json',
        responseValidator: async (data) => {
            return await zGetRelationsResponse.parseAsync(data);
        },
        url: '/relations',
        ...options
    });
};

/**
 * Create a Relation
 *
 * Create a new relation.
 */
export const createRelation = <ThrowOnError extends boolean = false>(options?: Options<CreateRelationData, ThrowOnError>) => {
    return (options?.client ?? client).post<CreateRelationResponses, CreateRelationErrors, ThrowOnError>({
        querySerializer: {
            parameters: {
                fields: {
                    array: {
                        explode: false
                    }
                }
            }
        },
        requestValidator: async (data) => {
            return await zCreateRelationData.parseAsync(data);
        },
        responseType: 'json',
        responseValidator: async (data) => {
            return await zCreateRelationResponse.parseAsync(data);
        },
        url: '/relations',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options?.headers
        }
    });
};

/**
 * Delete a Relation
 *
 * Delete an existing relation.
 */
export const deleteRelation = <ThrowOnError extends boolean = false>(options: Options<DeleteRelationData, ThrowOnError>) => {
    return (options.client ?? client).delete<DeleteRelationResponses, DeleteRelationErrors, ThrowOnError>({
        requestValidator: async (data) => {
            return await zDeleteRelationData.parseAsync(data);
        },
        url: '/relations/{id}',
        ...options
    });
};

/**
 * Retrieve a Relation
 *
 * Retrieve a single relation by unique identifier.
 */
export const getRelation = <ThrowOnError extends boolean = false>(options: Options<GetRelationData, ThrowOnError>) => {
    return (options.client ?? client).get<GetRelationResponses, GetRelationErrors, ThrowOnError>({
        querySerializer: {
            parameters: {
                fields: {
                    array: {
                        explode: false
                    }
                }
            }
        },
        requestValidator: async (data) => {
            return await zGetRelationData.parseAsync(data);
        },
        responseType: 'json',
        responseValidator: async (data) => {
            return await zGetRelationResponse.parseAsync(data);
        },
        url: '/relations/{id}',
        ...options
    });
};

/**
 * Update a Relation
 *
 * Update an existing relation
 */
export const updateRelation = <ThrowOnError extends boolean = false>(options: Options<UpdateRelationData, ThrowOnError>) => {
    return (options.client ?? client).patch<UpdateRelationResponses, UpdateRelationErrors, ThrowOnError>({
        querySerializer: {
            parameters: {
                fields: {
                    array: {
                        explode: false
                    }
                }
            }
        },
        requestValidator: async (data) => {
            return await zUpdateRelationData.parseAsync(data);
        },
        responseType: 'json',
        responseValidator: async (data) => {
            return await zUpdateRelationResponse.parseAsync(data);
        },
        url: '/relations/{id}',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Delete Multiple Presets
 *
 * Delete multiple existing presets.
 */
export const deletePresets = <ThrowOnError extends boolean = false>(options?: Options<DeletePresetsData, ThrowOnError>) => {
    return (options?.client ?? client).delete<DeletePresetsResponses, DeletePresetsErrors, ThrowOnError>({
        requestValidator: async (data) => {
            return await zDeletePresetsData.parseAsync(data);
        },
        url: '/presets',
        ...options
    });
};

/**
 * List Presets
 *
 * List the presets.
 */
export const getPresets = <ThrowOnError extends boolean = false>(options?: Options<GetPresetsData, ThrowOnError>) => {
    return (options?.client ?? client).get<GetPresetsResponses, GetPresetsErrors, ThrowOnError>({
        querySerializer: {
            parameters: {
                fields: {
                    array: {
                        explode: false
                    }
                },
                sort: {
                    array: {
                        explode: false
                    }
                },
                filter: {
                    object: {
                        style: 'form'
                    }
                }
            }
        },
        requestValidator: async (data) => {
            return await zGetPresetsData.parseAsync(data);
        },
        responseType: 'json',
        responseValidator: async (data) => {
            return await zGetPresetsResponse.parseAsync(data);
        },
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/presets',
        ...options
    });
};

/**
 * Update Multiple Presets
 *
 * Update multiple presets at the same time.
 */
export const updatePresets = <ThrowOnError extends boolean = false>(options?: Options<UpdatePresetsData, ThrowOnError>) => {
    return (options?.client ?? client).patch<UpdatePresetsResponses, UpdatePresetsErrors, ThrowOnError>({
        querySerializer: {
            parameters: {
                fields: {
                    array: {
                        explode: false
                    }
                },
                sort: {
                    array: {
                        explode: false
                    }
                },
                filter: {
                    object: {
                        style: 'form'
                    }
                }
            }
        },
        requestValidator: async (data) => {
            return await zUpdatePresetsData.parseAsync(data);
        },
        responseType: 'json',
        responseValidator: async (data) => {
            return await zUpdatePresetsResponse.parseAsync(data);
        },
        url: '/presets',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options?.headers
        }
    });
};

/**
 * Create a Preset
 *
 * Create a new preset.
 */
export const createPreset = <ThrowOnError extends boolean = false>(options?: Options<CreatePresetData, ThrowOnError>) => {
    return (options?.client ?? client).post<CreatePresetResponses, CreatePresetErrors, ThrowOnError>({
        querySerializer: {
            parameters: {
                fields: {
                    array: {
                        explode: false
                    }
                }
            }
        },
        requestValidator: async (data) => {
            return await zCreatePresetData.parseAsync(data);
        },
        responseType: 'json',
        responseValidator: async (data) => {
            return await zCreatePresetResponse.parseAsync(data);
        },
        url: '/presets',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options?.headers
        }
    });
};

/**
 * Delete a Preset
 *
 * Delete an existing preset.
 */
export const deletePreset = <ThrowOnError extends boolean = false>(options: Options<DeletePresetData, ThrowOnError>) => {
    return (options.client ?? client).delete<DeletePresetResponses, DeletePresetErrors, ThrowOnError>({
        requestValidator: async (data) => {
            return await zDeletePresetData.parseAsync(data);
        },
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/presets/{id}',
        ...options
    });
};

/**
 * Retrieve a Preset
 *
 * Retrieve a single preset by unique identifier.
 */
export const getPreset = <ThrowOnError extends boolean = false>(options: Options<GetPresetData, ThrowOnError>) => {
    return (options.client ?? client).get<GetPresetResponses, GetPresetErrors, ThrowOnError>({
        querySerializer: {
            parameters: {
                fields: {
                    array: {
                        explode: false
                    }
                }
            }
        },
        requestValidator: async (data) => {
            return await zGetPresetData.parseAsync(data);
        },
        responseType: 'json',
        responseValidator: async (data) => {
            return await zGetPresetResponse.parseAsync(data);
        },
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/presets/{id}',
        ...options
    });
};

/**
 * Update a Preset
 *
 * Update an existing preset.
 */
export const updatePreset = <ThrowOnError extends boolean = false>(options: Options<UpdatePresetData, ThrowOnError>) => {
    return (options.client ?? client).patch<UpdatePresetResponses, UpdatePresetErrors, ThrowOnError>({
        querySerializer: {
            parameters: {
                fields: {
                    array: {
                        explode: false
                    }
                }
            }
        },
        requestValidator: async (data) => {
            return await zUpdatePresetData.parseAsync(data);
        },
        responseType: 'json',
        responseValidator: async (data) => {
            return await zUpdatePresetResponse.parseAsync(data);
        },
        url: '/presets/{id}',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * List Revisions
 *
 * List the revisions.
 */
export const getRevisions = <ThrowOnError extends boolean = false>(options?: Options<GetRevisionsData, ThrowOnError>) => {
    return (options?.client ?? client).get<GetRevisionsResponses, GetRevisionsErrors, ThrowOnError>({
        querySerializer: {
            parameters: {
                fields: {
                    array: {
                        explode: false
                    }
                },
                sort: {
                    array: {
                        explode: false
                    }
                },
                filter: {
                    object: {
                        style: 'form'
                    }
                }
            }
        },
        requestValidator: async (data) => {
            return await zGetRevisionsData.parseAsync(data);
        },
        responseType: 'json',
        responseValidator: async (data) => {
            return await zGetRevisionsResponse.parseAsync(data);
        },
        url: '/revisions',
        ...options
    });
};

/**
 * Retrieve a Revision
 *
 * Retrieve a single revision by unique identifier.
 */
export const getRevision = <ThrowOnError extends boolean = false>(options: Options<GetRevisionData, ThrowOnError>) => {
    return (options.client ?? client).get<GetRevisionResponses, GetRevisionErrors, ThrowOnError>({
        querySerializer: {
            parameters: {
                fields: {
                    array: {
                        explode: false
                    }
                }
            }
        },
        requestValidator: async (data) => {
            return await zGetRevisionData.parseAsync(data);
        },
        responseType: 'json',
        responseValidator: async (data) => {
            return await zGetRevisionResponse.parseAsync(data);
        },
        url: '/revisions/{id}',
        ...options
    });
};

/**
 * Retrieve Settings
 *
 * List the settings.
 */
export const getSettings = <ThrowOnError extends boolean = false>(options?: Options<GetSettingsData, ThrowOnError>) => {
    return (options?.client ?? client).get<GetSettingsResponses, GetSettingsErrors, ThrowOnError>({
        requestValidator: async (data) => {
            return await zGetSettingsData.parseAsync(data);
        },
        responseType: 'json',
        responseValidator: async (data) => {
            return await zGetSettingsResponse.parseAsync(data);
        },
        url: '/settings',
        ...options
    });
};

/**
 * Update Settings
 *
 * Update the settings
 */
export const updateSetting = <ThrowOnError extends boolean = false>(options?: Options<UpdateSettingData, ThrowOnError>) => {
    return (options?.client ?? client).patch<UpdateSettingResponses, UpdateSettingErrors, ThrowOnError>({
        requestValidator: async (data) => {
            return await zUpdateSettingData.parseAsync(data);
        },
        responseType: 'json',
        responseValidator: async (data) => {
            return await zUpdateSettingResponse.parseAsync(data);
        },
        url: '/settings',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options?.headers
        }
    });
};

/**
 * Delete Multiple Webhooks
 *
 * Delete multiple existing webhooks.
 */
export const deleteWebhooks = <ThrowOnError extends boolean = false>(options?: Options<DeleteWebhooksData, ThrowOnError>) => {
    return (options?.client ?? client).delete<DeleteWebhooksResponses, DeleteWebhooksErrors, ThrowOnError>({
        requestValidator: async (data) => {
            return await zDeleteWebhooksData.parseAsync(data);
        },
        url: '/webhooks',
        ...options
    });
};

/**
 * List Webhooks
 *
 * Get all webhooks.
 */
export const getWebhooks = <ThrowOnError extends boolean = false>(options?: Options<GetWebhooksData, ThrowOnError>) => {
    return (options?.client ?? client).get<GetWebhooksResponses, GetWebhooksErrors, ThrowOnError>({
        requestValidator: async (data) => {
            return await zGetWebhooksData.parseAsync(data);
        },
        responseType: 'json',
        responseValidator: async (data) => {
            return await zGetWebhooksResponse.parseAsync(data);
        },
        url: '/webhooks',
        ...options
    });
};

/**
 * Update Multiple Webhooks
 *
 * Update multiple webhooks at the same time.
 */
export const updateWebhooks = <ThrowOnError extends boolean = false>(options?: Options<UpdateWebhooksData, ThrowOnError>) => {
    return (options?.client ?? client).patch<UpdateWebhooksResponses, UpdateWebhooksErrors, ThrowOnError>({
        querySerializer: {
            parameters: {
                fields: {
                    array: {
                        explode: false
                    }
                },
                sort: {
                    array: {
                        explode: false
                    }
                },
                filter: {
                    object: {
                        style: 'form'
                    }
                }
            }
        },
        requestValidator: async (data) => {
            return await zUpdateWebhooksData.parseAsync(data);
        },
        responseType: 'json',
        responseValidator: async (data) => {
            return await zUpdateWebhooksResponse.parseAsync(data);
        },
        url: '/webhooks',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options?.headers
        }
    });
};

/**
 * Create a Webhook
 *
 * Create a new webhook.
 */
export const createWebhook = <ThrowOnError extends boolean = false>(options?: Options<CreateWebhookData, ThrowOnError>) => {
    return (options?.client ?? client).post<CreateWebhookResponses, CreateWebhookErrors, ThrowOnError>({
        querySerializer: {
            parameters: {
                fields: {
                    array: {
                        explode: false
                    }
                }
            }
        },
        requestValidator: async (data) => {
            return await zCreateWebhookData.parseAsync(data);
        },
        responseType: 'json',
        responseValidator: async (data) => {
            return await zCreateWebhookResponse.parseAsync(data);
        },
        url: '/webhooks',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options?.headers
        }
    });
};

/**
 * Delete a Webhook
 *
 * Delete an existing webhook
 */
export const deleteWebhook = <ThrowOnError extends boolean = false>(options: Options<DeleteWebhookData, ThrowOnError>) => {
    return (options.client ?? client).delete<DeleteWebhookResponses, DeleteWebhookErrors, ThrowOnError>({
        requestValidator: async (data) => {
            return await zDeleteWebhookData.parseAsync(data);
        },
        url: '/webhooks/{id}',
        ...options
    });
};

/**
 * Retrieve a Webhook
 *
 * Retrieve a single webhook by unique identifier.
 */
export const getWebhook = <ThrowOnError extends boolean = false>(options: Options<GetWebhookData, ThrowOnError>) => {
    return (options.client ?? client).get<GetWebhookResponses, GetWebhookErrors, ThrowOnError>({
        requestValidator: async (data) => {
            return await zGetWebhookData.parseAsync(data);
        },
        responseType: 'json',
        responseValidator: async (data) => {
            return await zGetWebhookResponse.parseAsync(data);
        },
        url: '/webhooks/{id}',
        ...options
    });
};

/**
 * Update a Webhook
 *
 * Update an existing webhook
 */
export const updateWebhook = <ThrowOnError extends boolean = false>(options: Options<UpdateWebhookData, ThrowOnError>) => {
    return (options.client ?? client).patch<UpdateWebhookResponses, UpdateWebhookErrors, ThrowOnError>({
        querySerializer: {
            parameters: {
                fields: {
                    array: {
                        explode: false
                    }
                }
            }
        },
        requestValidator: async (data) => {
            return await zUpdateWebhookData.parseAsync(data);
        },
        responseType: 'json',
        responseValidator: async (data) => {
            return await zUpdateWebhookResponse.parseAsync(data);
        },
        url: '/webhooks/{id}',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Delete Multiple Items
 *
 * Delete multiple existing event items.
 */
export const deleteItemsEvent = <ThrowOnError extends boolean = false>(options?: Options<DeleteItemsEventData, ThrowOnError>) => {
    return (options?.client ?? client).delete<DeleteItemsEventResponses, DeleteItemsEventErrors, ThrowOnError>({
        requestValidator: async (data) => {
            return await zDeleteItemsEventData.parseAsync(data);
        },
        url: '/items/event',
        ...options
    });
};

/**
 * List Items
 *
 * List the event items.
 */
export const readItemsEvent = <ThrowOnError extends boolean = false>(options?: Options<ReadItemsEventData, ThrowOnError>) => {
    return (options?.client ?? client).get<ReadItemsEventResponses, ReadItemsEventErrors, ThrowOnError>({
        querySerializer: {
            parameters: {
                fields: {
                    array: {
                        explode: false
                    }
                },
                sort: {
                    array: {
                        explode: false
                    }
                },
                filter: {
                    object: {
                        style: 'form'
                    }
                }
            }
        },
        requestValidator: async (data) => {
            return await zReadItemsEventData.parseAsync(data);
        },
        responseType: 'json',
        responseValidator: async (data) => {
            return await zReadItemsEventResponse.parseAsync(data);
        },
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/items/event',
        ...options
    });
};

/**
 * Update Multiple Items
 *
 * Update multiple event items at the same time.
 */
export const updateItemsEvent = <ThrowOnError extends boolean = false>(options?: Options<UpdateItemsEventData, ThrowOnError>) => {
    return (options?.client ?? client).patch<UpdateItemsEventResponses, unknown, ThrowOnError>({
        querySerializer: {
            parameters: {
                fields: {
                    array: {
                        explode: false
                    }
                },
                sort: {
                    array: {
                        explode: false
                    }
                },
                filter: {
                    object: {
                        style: 'form'
                    }
                }
            }
        },
        requestValidator: async (data) => {
            return await zUpdateItemsEventData.parseAsync(data);
        },
        responseType: 'json',
        responseValidator: async (data) => {
            return await zUpdateItemsEventResponse.parseAsync(data);
        },
        url: '/items/event',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options?.headers
        }
    });
};

/**
 * Create an Item
 *
 * Create a new event item.
 */
export const createItemsEvent = <ThrowOnError extends boolean = false>(options?: Options<CreateItemsEventData, ThrowOnError>) => {
    return (options?.client ?? client).post<CreateItemsEventResponses, CreateItemsEventErrors, ThrowOnError>({
        requestValidator: async (data) => {
            return await zCreateItemsEventData.parseAsync(data);
        },
        responseType: 'json',
        responseValidator: async (data) => {
            return await zCreateItemsEventResponse.parseAsync(data);
        },
        url: '/items/event',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options?.headers
        }
    });
};

/**
 * Delete an Item
 *
 * Delete an existing event item.
 */
export const deleteSingleItemsEvent = <ThrowOnError extends boolean = false>(options: Options<DeleteSingleItemsEventData, ThrowOnError>) => {
    return (options.client ?? client).delete<DeleteSingleItemsEventResponses, DeleteSingleItemsEventErrors, ThrowOnError>({
        requestValidator: async (data) => {
            return await zDeleteSingleItemsEventData.parseAsync(data);
        },
        url: '/items/event/{id}',
        ...options
    });
};

/**
 * Retrieve an Item
 *
 * Retrieve a single event item by unique identifier.
 */
export const readSingleItemsEvent = <ThrowOnError extends boolean = false>(options: Options<ReadSingleItemsEventData, ThrowOnError>) => {
    return (options.client ?? client).get<ReadSingleItemsEventResponses, ReadSingleItemsEventErrors, ThrowOnError>({
        querySerializer: {
            parameters: {
                fields: {
                    array: {
                        explode: false
                    }
                }
            }
        },
        requestValidator: async (data) => {
            return await zReadSingleItemsEventData.parseAsync(data);
        },
        responseType: 'json',
        responseValidator: async (data) => {
            return await zReadSingleItemsEventResponse.parseAsync(data);
        },
        url: '/items/event/{id}',
        ...options
    });
};

/**
 * Update an Item
 *
 * Update an existing event item.
 */
export const updateSingleItemsEvent = <ThrowOnError extends boolean = false>(options: Options<UpdateSingleItemsEventData, ThrowOnError>) => {
    return (options.client ?? client).patch<UpdateSingleItemsEventResponses, UpdateSingleItemsEventErrors, ThrowOnError>({
        querySerializer: {
            parameters: {
                fields: {
                    array: {
                        explode: false
                    }
                }
            }
        },
        requestValidator: async (data) => {
            return await zUpdateSingleItemsEventData.parseAsync(data);
        },
        responseType: 'json',
        responseValidator: async (data) => {
            return await zUpdateSingleItemsEventResponse.parseAsync(data);
        },
        url: '/items/event/{id}',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Delete Multiple Content Versions
 *
 * Delete multiple existing Content Versions.
 */
export const deleteContentVersions = <ThrowOnError extends boolean = false>(options?: Options<DeleteContentVersionsData, ThrowOnError>) => {
    return (options?.client ?? client).delete<DeleteContentVersionsResponses, DeleteContentVersionsErrors, ThrowOnError>({
        requestValidator: async (data) => {
            return await zDeleteContentVersionsData.parseAsync(data);
        },
        url: '/versions',
        ...options
    });
};

/**
 * List Content Versions
 *
 * Get all Content Versions.
 */
export const getContentVersions = <ThrowOnError extends boolean = false>(options?: Options<GetContentVersionsData, ThrowOnError>) => {
    return (options?.client ?? client).get<GetContentVersionsResponses, GetContentVersionsErrors, ThrowOnError>({
        querySerializer: {
            parameters: {
                fields: {
                    array: {
                        explode: false
                    }
                },
                sort: {
                    array: {
                        explode: false
                    }
                },
                filter: {
                    object: {
                        style: 'form'
                    }
                }
            }
        },
        requestValidator: async (data) => {
            return await zGetContentVersionsData.parseAsync(data);
        },
        responseType: 'json',
        responseValidator: async (data) => {
            return await zGetContentVersionsResponse.parseAsync(data);
        },
        url: '/versions',
        ...options
    });
};

/**
 * Update Multiple Content Versions
 *
 * Update multiple Content Versions at the same time.
 */
export const updateContentVersions = <ThrowOnError extends boolean = false>(options?: Options<UpdateContentVersionsData, ThrowOnError>) => {
    return (options?.client ?? client).patch<UpdateContentVersionsResponses, UpdateContentVersionsErrors, ThrowOnError>({
        querySerializer: {
            parameters: {
                fields: {
                    array: {
                        explode: false
                    }
                },
                sort: {
                    array: {
                        explode: false
                    }
                },
                filter: {
                    object: {
                        style: 'form'
                    }
                }
            }
        },
        requestValidator: async (data) => {
            return await zUpdateContentVersionsData.parseAsync(data);
        },
        responseType: 'json',
        responseValidator: async (data) => {
            return await zUpdateContentVersionsResponse.parseAsync(data);
        },
        url: '/versions',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options?.headers
        }
    });
};

/**
 * Create Multiple Content Versions
 *
 * Create multiple new Content Versions.
 */
export const createContentVersion = <ThrowOnError extends boolean = false>(options?: Options<CreateContentVersionData, ThrowOnError>) => {
    return (options?.client ?? client).post<CreateContentVersionResponses, CreateContentVersionErrors, ThrowOnError>({
        querySerializer: {
            parameters: {
                fields: {
                    array: {
                        explode: false
                    }
                }
            }
        },
        requestValidator: async (data) => {
            return await zCreateContentVersionData.parseAsync(data);
        },
        responseType: 'json',
        responseValidator: async (data) => {
            return await zCreateContentVersionResponse.parseAsync(data);
        },
        url: '/versions',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options?.headers
        }
    });
};

/**
 * Delete a Content Version
 *
 * Delete an existing Content Version.
 */
export const deleteContentVersion = <ThrowOnError extends boolean = false>(options: Options<DeleteContentVersionData, ThrowOnError>) => {
    return (options.client ?? client).delete<DeleteContentVersionResponses, DeleteContentVersionErrors, ThrowOnError>({
        requestValidator: async (data) => {
            return await zDeleteContentVersionData.parseAsync(data);
        },
        url: '/versions/{id}',
        ...options
    });
};

/**
 * Retrieve a Content Version
 *
 * Retrieve a single Content Version by unique identifier.
 */
export const getContentVersion = <ThrowOnError extends boolean = false>(options: Options<GetContentVersionData, ThrowOnError>) => {
    return (options.client ?? client).get<GetContentVersionResponses, GetContentVersionErrors, ThrowOnError>({
        querySerializer: {
            parameters: {
                fields: {
                    array: {
                        explode: false
                    }
                }
            }
        },
        requestValidator: async (data) => {
            return await zGetContentVersionData.parseAsync(data);
        },
        responseType: 'json',
        responseValidator: async (data) => {
            return await zGetContentVersionResponse.parseAsync(data);
        },
        url: '/versions/{id}',
        ...options
    });
};

/**
 * Update a Content Version
 *
 * Update an existing Content Version.
 */
export const updateContentVersion = <ThrowOnError extends boolean = false>(options: Options<UpdateContentVersionData, ThrowOnError>) => {
    return (options.client ?? client).patch<UpdateContentVersionResponses, UpdateContentVersionErrors, ThrowOnError>({
        querySerializer: {
            parameters: {
                fields: {
                    array: {
                        explode: false
                    }
                }
            }
        },
        requestValidator: async (data) => {
            return await zUpdateContentVersionData.parseAsync(data);
        },
        responseType: 'json',
        responseValidator: async (data) => {
            return await zUpdateContentVersionResponse.parseAsync(data);
        },
        url: '/versions/{id}',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Save to a Content Version
 *
 * Save item changes to an existing Content Version.
 */
export const saveContentVersion = <ThrowOnError extends boolean = false>(options: Options<SaveContentVersionData, ThrowOnError>) => {
    return (options.client ?? client).post<SaveContentVersionResponses, SaveContentVersionErrors, ThrowOnError>({
        requestValidator: async (data) => {
            return await zSaveContentVersionData.parseAsync(data);
        },
        responseType: 'json',
        responseValidator: async (data) => {
            return await zSaveContentVersionResponse.parseAsync(data);
        },
        url: '/versions/{id}/save',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Compare a Content Version
 *
 * Compare an existing Content Version with the main version of the item.
 */
export const compareContentVersion = <ThrowOnError extends boolean = false>(options: Options<CompareContentVersionData, ThrowOnError>) => {
    return (options.client ?? client).get<CompareContentVersionResponses, CompareContentVersionErrors, ThrowOnError>({
        requestValidator: async (data) => {
            return await zCompareContentVersionData.parseAsync(data);
        },
        responseType: 'json',
        responseValidator: async (data) => {
            return await zCompareContentVersionResponse.parseAsync(data);
        },
        url: '/versions/{id}/compare',
        ...options
    });
};

/**
 * Promote a Content Version
 *
 * Pass the current hash of the main version of the item (obtained from the `compare` endpoint) along with an optional array of field names of which the values are to be promoted (by default, all fields are selected).
 */
export const promoteContentVersion = <ThrowOnError extends boolean = false>(options: Options<PromoteContentVersionData, ThrowOnError>) => {
    return (options.client ?? client).post<PromoteContentVersionResponses, PromoteContentVersionErrors, ThrowOnError>({
        requestValidator: async (data) => {
            return await zPromoteContentVersionData.parseAsync(data);
        },
        responseType: 'json',
        responseValidator: async (data) => {
            return await zPromoteContentVersionResponse.parseAsync(data);
        },
        url: '/versions/{id}/promote',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Delete Multiple Items
 *
 * Delete multiple existing wish_list items.
 */
export const deleteItemsWishList = <ThrowOnError extends boolean = false>(options?: Options<DeleteItemsWishListData, ThrowOnError>) => {
    return (options?.client ?? client).delete<DeleteItemsWishListResponses, DeleteItemsWishListErrors, ThrowOnError>({
        requestValidator: async (data) => {
            return await zDeleteItemsWishListData.parseAsync(data);
        },
        url: '/items/wish_list',
        ...options
    });
};

/**
 * List Items
 *
 * List the wish_list items.
 */
export const readItemsWishList = <ThrowOnError extends boolean = false>(options?: Options<ReadItemsWishListData, ThrowOnError>) => {
    return (options?.client ?? client).get<ReadItemsWishListResponses, ReadItemsWishListErrors, ThrowOnError>({
        querySerializer: {
            parameters: {
                fields: {
                    array: {
                        explode: false
                    }
                },
                sort: {
                    array: {
                        explode: false
                    }
                },
                filter: {
                    object: {
                        style: 'form'
                    }
                }
            }
        },
        requestValidator: async (data) => {
            return await zReadItemsWishListData.parseAsync(data);
        },
        responseType: 'json',
        responseValidator: async (data) => {
            return await zReadItemsWishListResponse.parseAsync(data);
        },
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/items/wish_list',
        ...options
    });
};

/**
 * Update Multiple Items
 *
 * Update multiple wish_list items at the same time.
 */
export const updateItemsWishList = <ThrowOnError extends boolean = false>(options?: Options<UpdateItemsWishListData, ThrowOnError>) => {
    return (options?.client ?? client).patch<UpdateItemsWishListResponses, unknown, ThrowOnError>({
        querySerializer: {
            parameters: {
                fields: {
                    array: {
                        explode: false
                    }
                },
                sort: {
                    array: {
                        explode: false
                    }
                },
                filter: {
                    object: {
                        style: 'form'
                    }
                }
            }
        },
        requestValidator: async (data) => {
            return await zUpdateItemsWishListData.parseAsync(data);
        },
        responseType: 'json',
        responseValidator: async (data) => {
            return await zUpdateItemsWishListResponse.parseAsync(data);
        },
        url: '/items/wish_list',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options?.headers
        }
    });
};

/**
 * Create an Item
 *
 * Create a new wish_list item.
 */
export const createItemsWishList = <ThrowOnError extends boolean = false>(options?: Options<CreateItemsWishListData, ThrowOnError>) => {
    return (options?.client ?? client).post<CreateItemsWishListResponses, CreateItemsWishListErrors, ThrowOnError>({
        requestValidator: async (data) => {
            return await zCreateItemsWishListData.parseAsync(data);
        },
        responseType: 'json',
        responseValidator: async (data) => {
            return await zCreateItemsWishListResponse.parseAsync(data);
        },
        url: '/items/wish_list',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options?.headers
        }
    });
};

/**
 * Delete an Item
 *
 * Delete an existing wish_list item.
 */
export const deleteSingleItemsWishList = <ThrowOnError extends boolean = false>(options: Options<DeleteSingleItemsWishListData, ThrowOnError>) => {
    return (options.client ?? client).delete<DeleteSingleItemsWishListResponses, DeleteSingleItemsWishListErrors, ThrowOnError>({
        requestValidator: async (data) => {
            return await zDeleteSingleItemsWishListData.parseAsync(data);
        },
        url: '/items/wish_list/{id}',
        ...options
    });
};

/**
 * Retrieve an Item
 *
 * Retrieve a single wish_list item by unique identifier.
 */
export const readSingleItemsWishList = <ThrowOnError extends boolean = false>(options: Options<ReadSingleItemsWishListData, ThrowOnError>) => {
    return (options.client ?? client).get<ReadSingleItemsWishListResponses, ReadSingleItemsWishListErrors, ThrowOnError>({
        querySerializer: {
            parameters: {
                fields: {
                    array: {
                        explode: false
                    }
                }
            }
        },
        requestValidator: async (data) => {
            return await zReadSingleItemsWishListData.parseAsync(data);
        },
        responseType: 'json',
        responseValidator: async (data) => {
            return await zReadSingleItemsWishListResponse.parseAsync(data);
        },
        url: '/items/wish_list/{id}',
        ...options
    });
};

/**
 * Update an Item
 *
 * Update an existing wish_list item.
 */
export const updateSingleItemsWishList = <ThrowOnError extends boolean = false>(options: Options<UpdateSingleItemsWishListData, ThrowOnError>) => {
    return (options.client ?? client).patch<UpdateSingleItemsWishListResponses, UpdateSingleItemsWishListErrors, ThrowOnError>({
        querySerializer: {
            parameters: {
                fields: {
                    array: {
                        explode: false
                    }
                }
            }
        },
        requestValidator: async (data) => {
            return await zUpdateSingleItemsWishListData.parseAsync(data);
        },
        responseType: 'json',
        responseValidator: async (data) => {
            return await zUpdateSingleItemsWishListResponse.parseAsync(data);
        },
        url: '/items/wish_list/{id}',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Delete Multiple Users
 *
 * Delete multiple existing users.
 */
export const deleteUsers = <ThrowOnError extends boolean = false>(options?: Options<DeleteUsersData, ThrowOnError>) => {
    return (options?.client ?? client).delete<DeleteUsersResponses, DeleteUsersErrors, ThrowOnError>({
        requestValidator: async (data) => {
            return await zDeleteUsersData.parseAsync(data);
        },
        url: '/users',
        ...options
    });
};

/**
 * List Users
 *
 * List the users.
 */
export const getUsers = <ThrowOnError extends boolean = false>(options?: Options<GetUsersData, ThrowOnError>) => {
    return (options?.client ?? client).get<GetUsersResponses, GetUsersErrors, ThrowOnError>({
        querySerializer: {
            parameters: {
                fields: {
                    array: {
                        explode: false
                    }
                },
                sort: {
                    array: {
                        explode: false
                    }
                },
                filter: {
                    object: {
                        style: 'form'
                    }
                }
            }
        },
        requestValidator: async (data) => {
            return await zGetUsersData.parseAsync(data);
        },
        responseType: 'json',
        responseValidator: async (data) => {
            return await zGetUsersResponse.parseAsync(data);
        },
        url: '/users',
        ...options
    });
};

/**
 * Update Multiple Users
 *
 * Update multiple users at the same time.
 */
export const updateUsers = <ThrowOnError extends boolean = false>(options?: Options<UpdateUsersData, ThrowOnError>) => {
    return (options?.client ?? client).patch<UpdateUsersResponses, UpdateUsersErrors, ThrowOnError>({
        querySerializer: {
            parameters: {
                fields: {
                    array: {
                        explode: false
                    }
                },
                sort: {
                    array: {
                        explode: false
                    }
                },
                filter: {
                    object: {
                        style: 'form'
                    }
                }
            }
        },
        requestValidator: async (data) => {
            return await zUpdateUsersData.parseAsync(data);
        },
        responseType: 'json',
        responseValidator: async (data) => {
            return await zUpdateUsersResponse.parseAsync(data);
        },
        url: '/users',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options?.headers
        }
    });
};

/**
 * Create a User
 *
 * Create a new user.
 */
export const createUser = <ThrowOnError extends boolean = false>(options?: Options<CreateUserData, ThrowOnError>) => {
    return (options?.client ?? client).post<CreateUserResponses, CreateUserErrors, ThrowOnError>({
        requestValidator: async (data) => {
            return await zCreateUserData.parseAsync(data);
        },
        responseType: 'json',
        responseValidator: async (data) => {
            return await zCreateUserResponse.parseAsync(data);
        },
        url: '/users',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options?.headers
        }
    });
};

/**
 * Delete a User
 *
 * Delete an existing user
 */
export const deleteUser = <ThrowOnError extends boolean = false>(options: Options<DeleteUserData, ThrowOnError>) => {
    return (options.client ?? client).delete<DeleteUserResponses, DeleteUserErrors, ThrowOnError>({
        requestValidator: async (data) => {
            return await zDeleteUserData.parseAsync(data);
        },
        url: '/users/{id}',
        ...options
    });
};

/**
 * Retrieve a User
 *
 * Retrieve a single user by unique identifier.
 */
export const getUser = <ThrowOnError extends boolean = false>(options: Options<GetUserData, ThrowOnError>) => {
    return (options.client ?? client).get<GetUserResponses, GetUserErrors, ThrowOnError>({
        querySerializer: {
            parameters: {
                fields: {
                    array: {
                        explode: false
                    }
                }
            }
        },
        requestValidator: async (data) => {
            return await zGetUserData.parseAsync(data);
        },
        responseType: 'json',
        responseValidator: async (data) => {
            return await zGetUserResponse.parseAsync(data);
        },
        url: '/users/{id}',
        ...options
    });
};

/**
 * Update a User
 *
 * Update an existing user
 */
export const updateUser = <ThrowOnError extends boolean = false>(options: Options<UpdateUserData, ThrowOnError>) => {
    return (options.client ?? client).patch<UpdateUserResponses, UpdateUserErrors, ThrowOnError>({
        querySerializer: {
            parameters: {
                fields: {
                    array: {
                        explode: false
                    }
                }
            }
        },
        requestValidator: async (data) => {
            return await zUpdateUserData.parseAsync(data);
        },
        responseType: 'json',
        responseValidator: async (data) => {
            return await zUpdateUserResponse.parseAsync(data);
        },
        url: '/users/{id}',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Invite User(s)
 *
 * Invites one or more users to this project. It creates a user with an invited status, and then sends an email to the user with instructions on how to activate their account.
 */
export const invite = <ThrowOnError extends boolean = false>(options?: Options<InviteData, ThrowOnError>) => {
    return (options?.client ?? client).post<InviteResponses, InviteErrors, ThrowOnError>({
        requestValidator: async (data) => {
            return await zInviteData.parseAsync(data);
        },
        responseType: 'json',
        responseValidator: async (data) => {
            return await zInviteResponse.parseAsync(data);
        },
        url: '/users/invite',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options?.headers
        }
    });
};

/**
 * Accept User Invite
 *
 * Accepts and enables an invited user using a JWT invitation token.
 */
export const acceptInvite = <ThrowOnError extends boolean = false>(options: Options<AcceptInviteData, ThrowOnError>) => {
    return (options.client ?? client).post<AcceptInviteResponses, AcceptInviteErrors, ThrowOnError>({
        requestValidator: async (data) => {
            return await zAcceptInviteData.parseAsync(data);
        },
        responseType: 'json',
        responseValidator: async (data) => {
            return await zAcceptInviteResponse.parseAsync(data);
        },
        url: '/users/invite/accept',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Retrieve Current User
 *
 * Retrieve the currently authenticated user.
 */
export const getMe = <ThrowOnError extends boolean = false>(options?: Options<GetMeData, ThrowOnError>) => {
    return (options?.client ?? client).get<GetMeResponses, GetMeErrors, ThrowOnError>({
        querySerializer: {
            parameters: {
                fields: {
                    array: {
                        explode: false
                    }
                }
            }
        },
        requestValidator: async (data) => {
            return await zGetMeData.parseAsync(data);
        },
        responseType: 'json',
        responseValidator: async (data) => {
            return await zGetMeResponse.parseAsync(data);
        },
        url: '/users/me',
        ...options
    });
};

/**
 * Update Current User
 *
 * Update the currently authenticated user.
 */
export const updateMe = <ThrowOnError extends boolean = false>(options?: Options<UpdateMeData, ThrowOnError>) => {
    return (options?.client ?? client).patch<UpdateMeResponses, UpdateMeErrors, ThrowOnError>({
        requestValidator: async (data) => {
            return await zUpdateMeData.parseAsync(data);
        },
        responseType: 'json',
        responseValidator: async (data) => {
            return await zUpdateMeResponse.parseAsync(data);
        },
        url: '/users/me',
        ...options
    });
};

/**
 * Update Last Page
 *
 * Updates the last used page field of the currently authenticated user. This is used internally to be able to open the Directus admin app from the last page you used.
 */
export const updateLastUsedPageMe = <ThrowOnError extends boolean = false>(options?: Options<UpdateLastUsedPageMeData, ThrowOnError>) => {
    return (options?.client ?? client).patch<UpdateLastUsedPageMeResponses, UpdateLastUsedPageMeErrors, ThrowOnError>({
        requestValidator: async (data) => {
            return await zUpdateLastUsedPageMeData.parseAsync(data);
        },
        url: '/users/me/track/page',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options?.headers
        }
    });
};

/**
 * Enable 2FA
 *
 * Enables two-factor authentication for the currently authenticated user.
 */
export const meTfaEnable = <ThrowOnError extends boolean = false>(options?: Options<MeTfaEnableData, ThrowOnError>) => {
    return (options?.client ?? client).post<MeTfaEnableResponses, MeTfaEnableErrors, ThrowOnError>({
        requestValidator: async (data) => {
            return await zMeTfaEnableData.parseAsync(data);
        },
        url: '/users/me/tfa/enable',
        ...options
    });
};

/**
 * Disable 2FA
 *
 * Disables two-factor authentication for the currently authenticated user.
 */
export const meTfaDisable = <ThrowOnError extends boolean = false>(options?: Options<MeTfaDisableData, ThrowOnError>) => {
    return (options?.client ?? client).post<MeTfaDisableResponses, MeTfaDisableErrors, ThrowOnError>({
        requestValidator: async (data) => {
            return await zMeTfaDisableData.parseAsync(data);
        },
        url: '/users/me/tfa/disable',
        ...options
    });
};

/**
 * Delete Multiple Items
 *
 * Delete multiple existing wish items.
 */
export const deleteItemsWish = <ThrowOnError extends boolean = false>(options?: Options<DeleteItemsWishData, ThrowOnError>) => {
    return (options?.client ?? client).delete<DeleteItemsWishResponses, DeleteItemsWishErrors, ThrowOnError>({
        requestValidator: async (data) => {
            return await zDeleteItemsWishData.parseAsync(data);
        },
        url: '/items/wish',
        ...options
    });
};

/**
 * List Items
 *
 * List the wish items.
 */
export const readItemsWish = <ThrowOnError extends boolean = false>(options?: Options<ReadItemsWishData, ThrowOnError>) => {
    return (options?.client ?? client).get<ReadItemsWishResponses, ReadItemsWishErrors, ThrowOnError>({
        querySerializer: {
            parameters: {
                fields: {
                    array: {
                        explode: false
                    }
                },
                sort: {
                    array: {
                        explode: false
                    }
                },
                filter: {
                    object: {
                        style: 'form'
                    }
                }
            }
        },
        requestValidator: async (data) => {
            return await zReadItemsWishData.parseAsync(data);
        },
        responseType: 'json',
        responseValidator: async (data) => {
            return await zReadItemsWishResponse.parseAsync(data);
        },
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/items/wish',
        ...options
    });
};

/**
 * Update Multiple Items
 *
 * Update multiple wish items at the same time.
 */
export const updateItemsWish = <ThrowOnError extends boolean = false>(options?: Options<UpdateItemsWishData, ThrowOnError>) => {
    return (options?.client ?? client).patch<UpdateItemsWishResponses, unknown, ThrowOnError>({
        querySerializer: {
            parameters: {
                fields: {
                    array: {
                        explode: false
                    }
                },
                sort: {
                    array: {
                        explode: false
                    }
                },
                filter: {
                    object: {
                        style: 'form'
                    }
                }
            }
        },
        requestValidator: async (data) => {
            return await zUpdateItemsWishData.parseAsync(data);
        },
        responseType: 'json',
        responseValidator: async (data) => {
            return await zUpdateItemsWishResponse.parseAsync(data);
        },
        url: '/items/wish',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options?.headers
        }
    });
};

/**
 * Create an Item
 *
 * Create a new wish item.
 */
export const createItemsWish = <ThrowOnError extends boolean = false>(options?: Options<CreateItemsWishData, ThrowOnError>) => {
    return (options?.client ?? client).post<CreateItemsWishResponses, CreateItemsWishErrors, ThrowOnError>({
        requestValidator: async (data) => {
            return await zCreateItemsWishData.parseAsync(data);
        },
        responseType: 'json',
        responseValidator: async (data) => {
            return await zCreateItemsWishResponse.parseAsync(data);
        },
        url: '/items/wish',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options?.headers
        }
    });
};

/**
 * Delete an Item
 *
 * Delete an existing wish item.
 */
export const deleteSingleItemsWish = <ThrowOnError extends boolean = false>(options: Options<DeleteSingleItemsWishData, ThrowOnError>) => {
    return (options.client ?? client).delete<DeleteSingleItemsWishResponses, DeleteSingleItemsWishErrors, ThrowOnError>({
        requestValidator: async (data) => {
            return await zDeleteSingleItemsWishData.parseAsync(data);
        },
        url: '/items/wish/{id}',
        ...options
    });
};

/**
 * Retrieve an Item
 *
 * Retrieve a single wish item by unique identifier.
 */
export const readSingleItemsWish = <ThrowOnError extends boolean = false>(options: Options<ReadSingleItemsWishData, ThrowOnError>) => {
    return (options.client ?? client).get<ReadSingleItemsWishResponses, ReadSingleItemsWishErrors, ThrowOnError>({
        querySerializer: {
            parameters: {
                fields: {
                    array: {
                        explode: false
                    }
                }
            }
        },
        requestValidator: async (data) => {
            return await zReadSingleItemsWishData.parseAsync(data);
        },
        responseType: 'json',
        responseValidator: async (data) => {
            return await zReadSingleItemsWishResponse.parseAsync(data);
        },
        url: '/items/wish/{id}',
        ...options
    });
};

/**
 * Update an Item
 *
 * Update an existing wish item.
 */
export const updateSingleItemsWish = <ThrowOnError extends boolean = false>(options: Options<UpdateSingleItemsWishData, ThrowOnError>) => {
    return (options.client ?? client).patch<UpdateSingleItemsWishResponses, UpdateSingleItemsWishErrors, ThrowOnError>({
        querySerializer: {
            parameters: {
                fields: {
                    array: {
                        explode: false
                    }
                }
            }
        },
        requestValidator: async (data) => {
            return await zUpdateSingleItemsWishData.parseAsync(data);
        },
        responseType: 'json',
        responseValidator: async (data) => {
            return await zUpdateSingleItemsWishResponse.parseAsync(data);
        },
        url: '/items/wish/{id}',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Delete Multiple Roles
 *
 * Delete multiple existing roles.
 */
export const deleteRoles = <ThrowOnError extends boolean = false>(options?: Options<DeleteRolesData, ThrowOnError>) => {
    return (options?.client ?? client).delete<DeleteRolesResponses, DeleteRolesErrors, ThrowOnError>({
        requestValidator: async (data) => {
            return await zDeleteRolesData.parseAsync(data);
        },
        url: '/roles',
        ...options
    });
};

/**
 * List Roles
 *
 * List the roles.
 */
export const getRoles = <ThrowOnError extends boolean = false>(options?: Options<GetRolesData, ThrowOnError>) => {
    return (options?.client ?? client).get<GetRolesResponses, GetRolesErrors, ThrowOnError>({
        querySerializer: {
            parameters: {
                fields: {
                    array: {
                        explode: false
                    }
                },
                sort: {
                    array: {
                        explode: false
                    }
                },
                filter: {
                    object: {
                        style: 'form'
                    }
                }
            }
        },
        requestValidator: async (data) => {
            return await zGetRolesData.parseAsync(data);
        },
        responseType: 'json',
        responseValidator: async (data) => {
            return await zGetRolesResponse.parseAsync(data);
        },
        url: '/roles',
        ...options
    });
};

/**
 * Update Multiple Roles
 *
 * Update multiple roles at the same time.
 */
export const updateRoles = <ThrowOnError extends boolean = false>(options?: Options<UpdateRolesData, ThrowOnError>) => {
    return (options?.client ?? client).patch<UpdateRolesResponses, UpdateRolesErrors, ThrowOnError>({
        querySerializer: {
            parameters: {
                fields: {
                    array: {
                        explode: false
                    }
                },
                sort: {
                    array: {
                        explode: false
                    }
                },
                filter: {
                    object: {
                        style: 'form'
                    }
                }
            }
        },
        requestValidator: async (data) => {
            return await zUpdateRolesData.parseAsync(data);
        },
        responseType: 'json',
        responseValidator: async (data) => {
            return await zUpdateRolesResponse.parseAsync(data);
        },
        url: '/roles',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options?.headers
        }
    });
};

/**
 * Create a Role
 *
 * Create a new role.
 */
export const createRole = <ThrowOnError extends boolean = false>(options?: Options<CreateRoleData, ThrowOnError>) => {
    return (options?.client ?? client).post<CreateRoleResponses, CreateRoleErrors, ThrowOnError>({
        querySerializer: {
            parameters: {
                fields: {
                    array: {
                        explode: false
                    }
                }
            }
        },
        requestValidator: async (data) => {
            return await zCreateRoleData.parseAsync(data);
        },
        responseType: 'json',
        responseValidator: async (data) => {
            return await zCreateRoleResponse.parseAsync(data);
        },
        url: '/roles',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options?.headers
        }
    });
};

/**
 * Delete a Role
 *
 * Delete an existing role
 */
export const deleteRole = <ThrowOnError extends boolean = false>(options: Options<DeleteRoleData, ThrowOnError>) => {
    return (options.client ?? client).delete<DeleteRoleResponses, DeleteRoleErrors, ThrowOnError>({
        requestValidator: async (data) => {
            return await zDeleteRoleData.parseAsync(data);
        },
        url: '/roles/{id}',
        ...options
    });
};

/**
 * Retrieve a Role
 *
 * Retrieve a single role by unique identifier.
 */
export const getRole = <ThrowOnError extends boolean = false>(options: Options<GetRoleData, ThrowOnError>) => {
    return (options.client ?? client).get<GetRoleResponses, GetRoleErrors, ThrowOnError>({
        querySerializer: {
            parameters: {
                fields: {
                    array: {
                        explode: false
                    }
                }
            }
        },
        requestValidator: async (data) => {
            return await zGetRoleData.parseAsync(data);
        },
        responseType: 'json',
        responseValidator: async (data) => {
            return await zGetRoleResponse.parseAsync(data);
        },
        url: '/roles/{id}',
        ...options
    });
};

/**
 * Update a Role
 *
 * Update an existing role
 */
export const updateRole = <ThrowOnError extends boolean = false>(options: Options<UpdateRoleData, ThrowOnError>) => {
    return (options.client ?? client).patch<UpdateRoleResponses, UpdateRoleErrors, ThrowOnError>({
        querySerializer: {
            parameters: {
                fields: {
                    array: {
                        explode: false
                    }
                }
            }
        },
        requestValidator: async (data) => {
            return await zUpdateRoleData.parseAsync(data);
        },
        responseType: 'json',
        responseValidator: async (data) => {
            return await zUpdateRoleResponse.parseAsync(data);
        },
        url: '/roles/{id}',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Delete Multiple Files
 *
 * Delete multiple existing files.
 */
export const deleteFiles = <ThrowOnError extends boolean = false>(options?: Options<DeleteFilesData, ThrowOnError>) => {
    return (options?.client ?? client).delete<DeleteFilesResponses, DeleteFilesErrors, ThrowOnError>({
        requestValidator: async (data) => {
            return await zDeleteFilesData.parseAsync(data);
        },
        url: '/files',
        ...options
    });
};

/**
 * List Files
 *
 * List the files.
 */
export const getFiles = <ThrowOnError extends boolean = false>(options?: Options<GetFilesData, ThrowOnError>) => {
    return (options?.client ?? client).get<GetFilesResponses, GetFilesErrors, ThrowOnError>({
        querySerializer: {
            parameters: {
                fields: {
                    array: {
                        explode: false
                    }
                },
                sort: {
                    array: {
                        explode: false
                    }
                },
                filter: {
                    object: {
                        style: 'form'
                    }
                }
            }
        },
        requestValidator: async (data) => {
            return await zGetFilesData.parseAsync(data);
        },
        responseType: 'json',
        responseValidator: async (data) => {
            return await zGetFilesResponse.parseAsync(data);
        },
        url: '/files',
        ...options
    });
};

/**
 * Update Multiple Files
 *
 * Update multiple files at the same time.
 */
export const updateFiles = <ThrowOnError extends boolean = false>(options?: Options<UpdateFilesData, ThrowOnError>) => {
    return (options?.client ?? client).patch<UpdateFilesResponses, UpdateFilesErrors, ThrowOnError>({
        querySerializer: {
            parameters: {
                fields: {
                    array: {
                        explode: false
                    }
                },
                sort: {
                    array: {
                        explode: false
                    }
                },
                filter: {
                    object: {
                        style: 'form'
                    }
                }
            }
        },
        requestValidator: async (data) => {
            return await zUpdateFilesData.parseAsync(data);
        },
        responseType: 'json',
        responseValidator: async (data) => {
            return await zUpdateFilesResponse.parseAsync(data);
        },
        url: '/files',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options?.headers
        }
    });
};

/**
 * Create a File
 *
 * Create a new file
 */
export const createFile = <ThrowOnError extends boolean = false>(options?: Options<CreateFileData, ThrowOnError>) => {
    return (options?.client ?? client).post<CreateFileResponses, CreateFileErrors, ThrowOnError>({
        requestValidator: async (data) => {
            return await zCreateFileData.parseAsync(data);
        },
        responseType: 'json',
        responseValidator: async (data) => {
            return await zCreateFileResponse.parseAsync(data);
        },
        url: '/files',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options?.headers
        }
    });
};

/**
 * Delete a File
 *
 * Delete an existing file.
 */
export const deleteFile = <ThrowOnError extends boolean = false>(options: Options<DeleteFileData, ThrowOnError>) => {
    return (options.client ?? client).delete<DeleteFileResponses, DeleteFileErrors, ThrowOnError>({
        requestValidator: async (data) => {
            return await zDeleteFileData.parseAsync(data);
        },
        url: '/files/{id}',
        ...options
    });
};

/**
 * Retrieve a Files
 *
 * Retrieve a single file by unique identifier.
 */
export const getFile = <ThrowOnError extends boolean = false>(options: Options<GetFileData, ThrowOnError>) => {
    return (options.client ?? client).get<GetFileResponses, GetFileErrors, ThrowOnError>({
        querySerializer: {
            parameters: {
                fields: {
                    array: {
                        explode: false
                    }
                }
            }
        },
        requestValidator: async (data) => {
            return await zGetFileData.parseAsync(data);
        },
        responseType: 'json',
        responseValidator: async (data) => {
            return await zGetFileResponse.parseAsync(data);
        },
        url: '/files/{id}',
        ...options
    });
};

/**
 * Update a File
 *
 * Update an existing file, and/or replace it's file contents.
 */
export const updateFile = <ThrowOnError extends boolean = false>(options: Options<UpdateFileData, ThrowOnError>) => {
    return (options.client ?? client).patch<UpdateFileResponses, UpdateFileErrors, ThrowOnError>({
        querySerializer: {
            parameters: {
                fields: {
                    array: {
                        explode: false
                    }
                }
            }
        },
        requestValidator: async (data) => {
            return await zUpdateFileData.parseAsync(data);
        },
        responseType: 'json',
        responseValidator: async (data) => {
            return await zUpdateFileResponse.parseAsync(data);
        },
        url: '/files/{id}',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};
